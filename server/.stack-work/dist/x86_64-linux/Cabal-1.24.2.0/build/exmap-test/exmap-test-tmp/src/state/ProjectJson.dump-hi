
==================== FINAL INTERFACE ====================
2017-08-25 19:23:25.326039712 UTC

interface main@main:ProjectJson [orphan module] 8002
  interface hash: 87e46438a249b05791ce80d73907298b
  ABI hash: 970ec5cec0779d33f29e586c13e11471
  export-list hash: 8bbcc50cbcad362d0c837cc2c1983857
  orphan hash: 49f67f39f3286a4df066c71322bbcc26
  flag hash: 6ced378db965c9ebc1e1b977ae5e6765
  sig of: Nothing
  used TH splices: False
  where
exports:
module dependencies: ApplicationTypes Errors Formula OperationTypes
                     Project TextEnums View XFunction XMapTypes XValues
package dependencies: aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK
                      array-0.5.1.1@array-0.5.1.1
                      attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna
                      base-4.9.1.0
                      base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      dlist-0.8.0.3@dlist-0.8.0.3-BHFBNaw8k6n9WiaUNzoXpk
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1
                      integer-logarithms-1.0.2@integer-logarithms-1.0.2-92lMiWV9mmYAwfMEYgfQ0D
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      scientific-0.3.5.1@scientific-0.3.5.1-JHsAAp34Yyd8e5v3sK3O5Q
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      time-1.6.0.1@time-1.6.0.1
                      time-locale-compat-0.1.1.3@time-locale-compat-0.1.1.3-KZ1jqNx8uhlHjmuPPj6V1Y
                      transformers-0.5.2.0@transformers-0.5.2.0
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
                      uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
orphans: attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.ByteString.Char8
         attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.Text.Internal
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.Internal.Types
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         dlist-0.8.0.3@dlist-0.8.0.3-BHFBNaw8k6n9WiaUNzoXpk:Data.DList
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Data.Primitive.Array
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
                         uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ:Data.UUID.Types.Internal
                         uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Storable
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed.Base
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson 2e25d14a91e9ff13092f56c3ec0cd425
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.FromJSON 4689ca8eaf34be826a16963134272afc
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.Internal c533249add6a1886866510b882a9b441
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.ToJSON 032e11a60f09165b3d041ef0b452cae8
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base a29df8c78ba14cbcd4d90f97bd8d22e9
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Strict f8f0196205d496398718e13b2f098e5d
import  -/  ApplicationTypes 143822343c6f7fa9393e7f65b91b4440
  exports: c8a509b10500b8e668c0d339e53814fa
  ApplicationName 7d51253c4c8955e3629ff4b12eb2b14e
import  -/  Formula 09444ea12c0441bd37404b175a926171
  exports: d6ceee93beb5ac820afa97f35b5fa611
  XFApplication eb8c3b77bcb22eb578439fc9251971f9
  XFMap 7dbf5543fca58ffc0e04840d8a0f5725
  XFOperation 81ff2bf2a641ffbde51c62d91ea8aaf4
  XFormula fb924f832976f886aefc5a3d03a23b47
import  -/  OperationTypes 6975e529b4a89f8050baa8dcbf38831a
  exports: 1a323fe5f5d42124be5996496a88719d
  OperationName a5a60b294983bcb41d5e4136aac111fd
import  -/  Project 93f6ca9e2846f86ac54ea76f28c190db
  exports: 0ac763d57d8349edb0646b40ee22ed42
  AllProjects c75321223c66abeb98e3bd6143c9f15e
  AllProjects 1c377e74b457ef6be4330578ab3f40d6
  Calculation 9cf8c9968a0f486e01e242b3852d7586
  Calculation adfd6319e00cd46d259efd671142244b
  HttpSource e65bfb0658ead3b334f0ac951818125d
  InternalSource 586326348aac4b83174278465fb1f183
  OdbcSource 6d04bb5d8524a2f49b1b420195776347
  Project 8aee35cbb1262b72aa43e8b6258fbbfc
  Project 13ec83e774735f0b026c71a7ea29a776
  ProjectName 3c11ef3f762183a44f6b8202508ef1c2
  ProjectName ba80df81fe4182e33b10c88286b7a889
  Source ec37a2c1fda5c192cf2083c285645624
  Source 4b26d70ae76240bb945c2111521b4b47
  SourceType 002b11e6f2ccaf95f9a6f16936609c77
  User ceddd9e2d653f6ed2c25af4f9b169cfd
  User d59ac36089c0c544b5f95ddd43105bc7
import  -/  TextEnums b3b2095ba14f86896b583957b7ebb21b
  exports: b4afc2047843291dc0b8b34e1a8eae93
  readT c50da94ac02a016fbe20df1e95b8c133
  showT 9da9061e371157579d8ad59cb1150038
import  -/  View 02361d7faa292e39c3bd07eb3d6b6b8e
  exports: 566a2406a41a78f1d65d3176e307799b
  LabelItem 3434f01a13626dc85c51091e03fdb138
  MapItem 708e458136cd9677a34a32de608f31f2
  View 9743bd334b51c92047571846fec7be71
  View 3a2375be1f5189e91eb0fabfa84fd0be
  ViewItem eb24c06f18238ff1494950db988ac0e9
  ViewLabel f2cda51f0694b9bffef52227952836e5
  ViewLabel 24961fd99fdaa15e1aebe70b7fc2c02b
  ViewName 4c6aad1e74bc6f916c25f7eddf2c9eb8
  ViewName 105e058b0f915624ee10874cf1c9d091
  ViewRow 184ac2a10a0416d6b9313091dbfe9519
  ViewRow a3fc67c22f4fd6049fe9dc14f457cef0
import  -/  XFunction bec8a66c7661d34fbdc693714232edf1
  exports: e4744bd862d5d39381a3b81764a14b8c
  OperationMode ba1024ee7488d74e75d2aa7e9c371660
import  -/  XMapTypes 83c3b05a6c33968c2e0bd82cfc322a5e
  exports: 63a1ffc24fb40991afaa24415fd501be
  XMap c2ed918b428722f1755c470b6338cf45
  XMapBool fc0289d5a53ceeb40b9eaf72c324dfad
  XMapDouble 64dca8f535e90282d4c575c17aea9c9a
  XMapInt d7e7675449f1dd11565e3e9279db009c
  XMapKey 9a8f689ba36840dff52b69a07d7eb5cf
  XMapKey 1916c309a17eb87a716b743dbaee092c
  XMapName 0be109e6102724ac02eab934889766c9
  XMapName aed4e1c98ee09424176ec799b4e99672
  XMapString 31f61ddbcce00d56a11eab12eda7e3f5
  XNamedMap 7cf2fcb1a016d4dff7eb6742faa16f39
  XNamedMap eb3d1aa1ee70c44efd717a55a4d51a32
import  -/  text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text 28074c70d3351fb3368d27c0a438ae07
import  -/  unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base 42bdf194c392fb9c910c94a2b5aa1ff1
import  -/  unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Lazy fc12dd068603a4b3dd39186b8a9fe7b5
32e27a462896632cddb59e9902b7a74f
  $fFromJSONAllProjects ::
    Data.Aeson.Types.FromJSON.FromJSON Project.AllProjects
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.AllProjects
                  ProjectJson.$fFromJSONAllProjects_$cparseJSON
                  ProjectJson.$fFromJSONAllProjects_$cparseJSONList -}
d90b4409c166b44069072568c7dd1283
  $fFromJSONAllProjects1 ::
    [Data.Aeson.Types.Internal.Parser Project.AllProjects]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.AllProjects] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
57837c9d135645ab5374d390924205f3
  $fFromJSONAllProjects2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "[a]"#) -}
c79ce5a3204e52ccd404ca931f6d134e
  $fFromJSONAllProjects3 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "projectNames"#) -}
94ffa2118b1a8e3a66ddc18f2d517ba2
  $fFromJSONAllProjects4 ::
    [Data.Aeson.Types.Internal.Parser Project.ProjectName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.ProjectName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
69bcc4128baff73d86e713bae7f52e0b
  $fFromJSONAllProjects5 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [Project.ProjectName] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             [Project.ProjectName] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONAllProjects_msg3) -}
7e54d86199cde5867b4501921d1913c3
  $fFromJSONAllProjects6 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONAllProjects3 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
e03fd727bf27cf83a85e8d223504ad5b
  $fFromJSONAllProjects7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " not present"#) -}
dd1bd53c6f5ce2426626c9414928aba3
  $fFromJSONAllProjects8 ::
    Data.Aeson.Types.Internal.Parser Project.AllProjects
  {- Strictness: x -}
713c75b6ca2996bc0fce9e30cb50c95f
  $fFromJSONAllProjects_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.AllProjects
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT -> ProjectJson.$fFromJSONAllProjects8
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser [Project.ProjectName]
                        = case ProjectJson.$fFromJSONAllProjects3 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONAllProjects5
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[Project.ProjectName]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [Project.ProjectName]
                                 = ProjectJson.$fFromJSONAllProjects_$cparseJSONList1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           [Project.ProjectName] f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <[Project.ProjectName]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONAllProjects_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[Project.ProjectName]>_R)) } }
                      } in
                      (\ @ (f22 :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f22 r)
                         (ks :: Data.Aeson.Types.Internal.Success
                                  Project.AllProjects f22 r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0] <[Project.ProjectName]>_R)
                         @ f22
                         @ r
                         path
                         kf
                         (\ (a2 :: [Project.ProjectName]) ->
                          ks a2 `cast` (Sym (Project.N:AllProjects[0]))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Project.AllProjects>_R)) }) -}
825e8a8b6e92675e0b9fac288767ba65
  $fFromJSONAllProjects_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.AllProjects]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.AllProjects]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONAllProjects1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONAllProjects_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.AllProjects]>_R)) } }) -}
ee6ef47edc9cc9aeab46a6e3c7a654cc
  $fFromJSONAllProjects_$cparseJSONList1 ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.ProjectName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.ProjectName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONAllProjects4
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONAllProjects_go1 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.ProjectName]>_R)) } }) -}
bbab1fb219a605e1a64c2f3f78d627d2
  $fFromJSONAllProjects_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.AllProjects]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
3f6aed9663b591c817c09785ba71ae7a
  $fFromJSONAllProjects_go1 ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.ProjectName]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
38768ab5e0c2529e2829eb63b7fced07
  $fFromJSONAllProjects_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONAllProjects6) -}
0272f579253be75e117e81ee463ceb32
  $fFromJSONAllProjects_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONAllProjects3) -}
28816806962d4449fb2473f56728f101
  $fFromJSONApplicationName ::
    Data.Aeson.Types.FromJSON.FromJSON ApplicationTypes.ApplicationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ApplicationTypes.ApplicationName
                  ProjectJson.$fFromJSONApplicationName_$cparseJSON
                  ProjectJson.$fFromJSONApplicationName_$cparseJSONList -}
68dc5e2e72f35df3c0f17ddd07c83161
  $fFromJSONApplicationName1 ::
    [Data.Aeson.Types.Internal.Parser ApplicationTypes.ApplicationName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            [ApplicationTypes.ApplicationName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
9c31581053b4920fc9fcf70170bb41d5
  $fFromJSONApplicationName2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            ApplicationTypes.ApplicationName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              ApplicationTypes.ApplicationName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> case ProjectJson.$fFromJSONApplicationName3 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2
                        (TextEnums.readT
                           @ ApplicationTypes.ApplicationName
                           ApplicationTypes.$fReadApplicationName
                           v) }) -}
60749e0ac910ac5b05bc4a8ec50b3698
  $fFromJSONApplicationName3 ::
    Data.Aeson.Types.Internal.Parser ApplicationTypes.ApplicationName
  {- Strictness: x -}
5b8d0a92e7efea490e77500f15c11810
  $fFromJSONApplicationName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser
         ApplicationTypes.ApplicationName
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONApplicationName2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <ApplicationTypes.ApplicationName>_R)) -}
998d4de014747aac828391faa0ea172a
  $fFromJSONApplicationName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser
         [ApplicationTypes.ApplicationName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [ApplicationTypes.ApplicationName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONApplicationName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONApplicationName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[ApplicationTypes.ApplicationName]>_R)) } }) -}
14785f18be15d9e69e32dbd47d308567
  $fFromJSONApplicationName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser
          ApplicationTypes.ApplicationName]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
751cf97158e5631e54f64e4bb5fe4d3f
  $fFromJSONCalculation ::
    Data.Aeson.Types.FromJSON.FromJSON Project.Calculation
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Calculation
                  ProjectJson.$fFromJSONCalculation_$cparseJSON
                  ProjectJson.$fFromJSONCalculation_$cparseJSONList -}
46ed13db80e042bf290cb67bf8563827
  $fFromJSONCalculation1 ::
    [Data.Aeson.Types.Internal.Parser Project.Calculation]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.Calculation] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
a96e63f5e902010afefb90a781409b45
  $fFromJSONCalculation_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.Calculation
  {- Arity: 1, Strictness: <S,1*U> -}
d945a3b76ff3373c603069cd16748bca
  $fFromJSONCalculation_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.Calculation]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.Calculation]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONCalculation1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONCalculation_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.Calculation]>_R)) } }) -}
61c157a5a6ba615433d2efad9f430722
  $fFromJSONCalculation_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.Calculation]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
881bc3e27145bb7de00e419116f41c0d
  $fFromJSONOperationMode ::
    Data.Aeson.Types.FromJSON.FromJSON XFunction.OperationMode
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XFunction.OperationMode
                  ProjectJson.$fFromJSONOperationMode_$cparseJSON
                  ProjectJson.$fFromJSONOperationMode_$cparseJSONList -}
aa8587da545df778656a56d3ea69e0f5
  $fFromJSONOperationMode1 ::
    [Data.Aeson.Types.Internal.Parser XFunction.OperationMode]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XFunction.OperationMode] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
15218bac54692a4ac29644564b5c9294
  $fFromJSONOperationMode2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success XFunction.OperationMode f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              XFunction.OperationMode f r) ->
                 case ds of wild {
                   DEFAULT
                   -> case ProjectJson.$fFromJSONOperationMode3 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2
                        (TextEnums.readT
                           @ XFunction.OperationMode
                           XFunction.$fReadOperationMode
                           v) }) -}
32103303f69459f5bd8995ebcb8551e4
  $fFromJSONOperationMode3 ::
    Data.Aeson.Types.Internal.Parser XFunction.OperationMode
  {- Strictness: x -}
1dbdb534a83e8ac30016198b04bfb491
  $fFromJSONOperationMode_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XFunction.OperationMode
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONOperationMode2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <XFunction.OperationMode>_R)) -}
03b72a01124b3bfbcb38b50c2e63b6de
  $fFromJSONOperationMode_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XFunction.OperationMode]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XFunction.OperationMode]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONOperationMode1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONOperationMode_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XFunction.OperationMode]>_R)) } }) -}
c4db5fa2ac3c0e959609ff4c233f6677
  $fFromJSONOperationMode_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XFunction.OperationMode]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
f5961ae8834294274d786dd9fd23ee98
  $fFromJSONOperationName ::
    Data.Aeson.Types.FromJSON.FromJSON OperationTypes.OperationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ OperationTypes.OperationName
                  ProjectJson.$fFromJSONOperationName_$cparseJSON
                  ProjectJson.$fFromJSONOperationName_$cparseJSONList -}
27e200fb04164cb46106fa0e4e5c4268
  $fFromJSONOperationName1 ::
    [Data.Aeson.Types.Internal.Parser OperationTypes.OperationName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            [OperationTypes.OperationName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
dbba701d2f66156e7a048c0b9b1a5e8c
  $fFromJSONOperationName2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            OperationTypes.OperationName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              OperationTypes.OperationName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> case ProjectJson.$fFromJSONOperationName3 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2
                        (TextEnums.readT
                           @ OperationTypes.OperationName
                           OperationTypes.$fReadOperationName
                           v) }) -}
f84f416dde4d6234195a3ceb3955aa94
  $fFromJSONOperationName3 ::
    Data.Aeson.Types.Internal.Parser OperationTypes.OperationName
  {- Strictness: x -}
20193b3db6e26fe50d03137fd5561e14
  $fFromJSONOperationName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser OperationTypes.OperationName
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONOperationName2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <OperationTypes.OperationName>_R)) -}
5756080a40b9e8de41fee4acd44a1611
  $fFromJSONOperationName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [OperationTypes.OperationName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [OperationTypes.OperationName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONOperationName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONOperationName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[OperationTypes.OperationName]>_R)) } }) -}
3e18fa439b56616a4039f4ba3c7d7ef6
  $fFromJSONOperationName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser OperationTypes.OperationName]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
6e797f768671359430fff9db9d3f0fda
  $fFromJSONProject ::
    Data.Aeson.Types.FromJSON.FromJSON Project.Project
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Project
                  ProjectJson.$fFromJSONProject_$cparseJSON
                  ProjectJson.$fFromJSONProject_$cparseJSONList -}
262abef8e6da300ed3267e3f1949cefa
  $fFromJSONProject1 ::
    [Data.Aeson.Types.Internal.Parser Project.Project]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.Project] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
db77f9d19a732c1c5b39492379475a19
  $fFromJSONProjectName ::
    Data.Aeson.Types.FromJSON.FromJSON Project.ProjectName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.ProjectName
                  ProjectJson.$fFromJSONProjectName_$cparseJSON
                  ProjectJson.$fFromJSONAllProjects_$cparseJSONList1 -}
8c585254edf04a0d17a614acd01bb23e
  $fFromJSONProjectName1 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success Project.ProjectName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              Project.ProjectName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> case ProjectJson.$fFromJSONProjectName2 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (Project.N:ProjectName[0])) }) -}
5392ec8e3af5b3bfaa394648529ca625
  $fFromJSONProjectName2 ::
    Data.Aeson.Types.Internal.Parser Project.ProjectName
  {- Strictness: x -}
2ab6810b6be81ee04ea5ac6566abe3fb
  $fFromJSONProjectName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.ProjectName
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONProjectName1
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <Project.ProjectName>_R)) -}
60a51a012bdbb8cab994840c3e4a2c12
  $fFromJSONProject_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.Project
  {- Arity: 1, Strictness: <S,1*U> -}
00dfbff1a75bdf5843034029fde84345
  $fFromJSONProject_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.Project]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.Project]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONProject1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONProject_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.Project]>_R)) } }) -}
4d3cba277a78e5b88261b27f37e21654
  $fFromJSONProject_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.Project]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
06775a90840ae1054a527d86e3619ad1
  $fFromJSONSource ::
    Data.Aeson.Types.FromJSON.FromJSON Project.Source
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Source
                  ProjectJson.$fFromJSONSource_$cparseJSON
                  ProjectJson.$fFromJSONSource_$cparseJSONList -}
2943151f5f2a2f05b68babd52508bda1
  $fFromJSONSource1 ::
    [Data.Aeson.Types.Internal.Parser Project.Source]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.Source] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
024ebc487032712c7d47f2146793819d
  $fFromJSONSource2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "sourceOfMaps"#) -}
23b9d728312e55065edcd6264ffa5399
  $fFromJSONSource3 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XMapName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XMapName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
697447cde894ddbbbe766fc3a82fbd2b
  $fFromJSONSource4 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [XMapTypes.XMapName] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             [XMapTypes.XMapName] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONSource_msg3) -}
74b2d280a34e3e3621b5a5ad6ebcfab3
  $fFromJSONSource5 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONSource2 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
54bcd1db225430d15520e9403bfd5f9a
  $fFromJSONSource6 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "sourceType"#) -}
3aa3002387c420b21cf15b60e6b5f3bd
  $fFromJSONSource7 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success Project.SourceType f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             Project.SourceType f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONSource_msg1) -}
03cee6f58c79adaa02323fb52d7bf103
  $fFromJSONSource8 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONSource6 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
81d804aa2b0f2071ec046f87cf60c0e7
  $fFromJSONSource9 ::
    Data.Aeson.Types.Internal.Parser Project.Source
  {- Strictness: x -}
b61d64aecb038cf793e3360c844559fd
  $fFromJSONSourceType ::
    Data.Aeson.Types.FromJSON.FromJSON Project.SourceType
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.SourceType
                  ProjectJson.$fFromJSONSource_$cparseJSON1
                  ProjectJson.$fFromJSONSourceType_$cparseJSONList -}
55d22fa58958637161312624e45e4bae
  $fFromJSONSourceType1 ::
    [Data.Aeson.Types.Internal.Parser Project.SourceType]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.SourceType] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
9f93a9367e530b7999c5f0269dce3294
  $fFromJSONSourceType_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.SourceType]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.SourceType]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONSourceType1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONSourceType_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.SourceType]>_R)) } }) -}
297dcc6e9160abbfd10b96fc066e7a7c
  $fFromJSONSourceType_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.SourceType]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
47038ada2cb8b7fd7b16f86b7276f896
  $fFromJSONSource_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.Source
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT -> ProjectJson.$fFromJSONSource9
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser Project.SourceType
                        = case ProjectJson.$fFromJSONSource6 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONSource7
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Project.SourceType>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser Project.SourceType
                                 = ProjectJson.$fFromJSONSource_$cparseJSON1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           Project.SourceType f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <Project.SourceType>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONSource_pathElem1
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Project.SourceType>_R)) } }
                      } in
                      let {
                        e :: Data.Aeson.Types.Internal.Parser [XMapTypes.XMapName]
                        = case ProjectJson.$fFromJSONSource2 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONSource4
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[XMapTypes.XMapName]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [XMapTypes.XMapName]
                                 = ProjectJson.$fFromJSONSource_$cparseJSONList1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           [XMapTypes.XMapName] f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <[XMapTypes.XMapName]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONSource_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[XMapTypes.XMapName]>_R)) } }
                      } in
                      (\ @ (f :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f r)
                         (ks :: Data.Aeson.Types.Internal.Success Project.Source f r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0] <Project.SourceType>_R)
                         @ f
                         @ r
                         path
                         kf
                         (\ (a2 :: Project.SourceType) ->
                          e `cast`
                          (Data.Aeson.Types.Internal.N:Parser[0] <[XMapTypes.XMapName]>_R)
                            @ f
                            @ r
                            path
                            kf
                            (\ (a3 :: [XMapTypes.XMapName]) -> ks (Project.Source a2 a3))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Project.Source>_R)) }) -}
011c53408195543c4c366ef56f6d1e67
  $fFromJSONSource_$cparseJSON1 ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.SourceType
  {- Arity: 1, Strictness: <S,1*U> -}
be15c25eb5d9cf97c3ac7fab6467efca
  $fFromJSONSource_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.Source]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.Source]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONSource1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONSource_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.Source]>_R)) } }) -}
c142d23fa657411edb85aefbffdb3bfe
  $fFromJSONSource_$cparseJSONList1 ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XMapName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XMapName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONSource3
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONSource_go1 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XMapName]>_R)) } }) -}
ea98d8b692170bf4195f08edb801caf7
  $fFromJSONSource_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.Source]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
3dc379160f4b130aadcf8c5b76e67eb0
  $fFromJSONSource_go1 ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XMapName]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
a37eda890b2ad22c2cb42c93bd652c64
  $fFromJSONSource_msg1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONSource8) -}
b0cefb78e5c1b1666059cda2784ff884
  $fFromJSONSource_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONSource5) -}
42b5cf822cb6710199898e21b9bf1a37
  $fFromJSONSource_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONSource2) -}
8a1438aa5594917918351dbf022e2fa2
  $fFromJSONSource_pathElem1 ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONSource6) -}
23ac369b44f28731e9af5a9b81595336
  $fFromJSONUser :: Data.Aeson.Types.FromJSON.FromJSON Project.User
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.User
                  ProjectJson.$fFromJSONUser_$cparseJSON
                  ProjectJson.$fFromJSONUser_$cparseJSONList -}
5360883be31d2a82e54aa9c9292a51a2
  $fFromJSONUser1 ::
    [Data.Aeson.Types.Internal.Parser Project.User]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.User] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
912f1b192a71ff847884187986e26ecc
  $fFromJSONUser2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   "accessToProjects"#) -}
feb76470d28504c71b5a9096f15947c1
  $fFromJSONUser3 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [Project.ProjectName] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             [Project.ProjectName] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONUser_msg3) -}
74128c5ad3394c40d124d1a23bb8ce19
  $fFromJSONUser4 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONUser2 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
dcc8e23a9c8a15ee4a01904dca911c6c
  $fFromJSONUser5 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "userId"#) -}
7427df1bc36c1b430b6a7a4cf6641f50
  $fFromJSONUser6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Text"#) -}
b860a442f7d63eefb7bb14d4f180f01b
  $fFromJSONUser7 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success Data.Text.Internal.Text f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             Data.Text.Internal.Text f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONUser_msg1) -}
8ad83fe455eaf633a298679ff8d22d0b
  $fFromJSONUser8 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONUser5 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
9ce76a50153e874d3dd5cebf83f7eb07
  $fFromJSONUser9 :: Data.Aeson.Types.Internal.Parser Project.User
  {- Strictness: x -}
75cda5b972d165ec6d16e159b25fc9c2
  $fFromJSONUser_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.User
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT -> ProjectJson.$fFromJSONUser9
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser Data.Text.Internal.Text
                        = case ProjectJson.$fFromJSONUser5 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONUser7
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Data.Text.Internal.Text>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser Data.Text.Internal.Text
                                 = case v1 of wild2 {
                                     DEFAULT
                                     -> Data.Aeson.Types.FromJSON.typeMismatch
                                          @ Data.Text.Internal.Text
                                          ProjectJson.$fFromJSONUser6
                                          wild2
                                     Data.Aeson.Types.Internal.String txt
                                     -> (\ @ (f :: * -> *)
                                           @ r
                                           (_path :: Data.Aeson.Types.Internal.JSONPath)
                                           (_kf :: Data.Aeson.Types.Internal.Failure f r)
                                           (ks :: Data.Aeson.Types.Internal.Success
                                                    Data.Text.Internal.Text f r) ->
                                         ks txt)
                                          `cast`
                                        (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                                  <Data.Text.Internal.Text>_R)) }
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           Data.Text.Internal.Text f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <Data.Text.Internal.Text>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONUser_pathElem1
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Data.Text.Internal.Text>_R)) } }
                      } in
                      let {
                        e :: Data.Aeson.Types.Internal.Parser [Project.ProjectName]
                        = case ProjectJson.$fFromJSONUser2 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONUser3
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[Project.ProjectName]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [Project.ProjectName]
                                 = ProjectJson.$fFromJSONAllProjects_$cparseJSONList1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           [Project.ProjectName] f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <[Project.ProjectName]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONUser_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[Project.ProjectName]>_R)) } }
                      } in
                      (\ @ (f :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f r)
                         (ks :: Data.Aeson.Types.Internal.Success Project.User f r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0] <Data.Text.Internal.Text>_R)
                         @ f
                         @ r
                         path
                         kf
                         (\ (a2 :: Data.Text.Internal.Text) ->
                          e `cast`
                          (Data.Aeson.Types.Internal.N:Parser[0] <[Project.ProjectName]>_R)
                            @ f
                            @ r
                            path
                            kf
                            (\ (a3 :: [Project.ProjectName]) -> ks (Project.User a2 a3))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Project.User>_R)) }) -}
cc5c51e42bd19860f43117f057fb9450
  $fFromJSONUser_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.User]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.User]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONUser1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONUser_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.User]>_R)) } }) -}
bd937c45d8d9b4abe502988e4d3b12ea
  $fFromJSONUser_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.User]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
7f7a013d3107f2c0a49e180b7dbd563a
  $fFromJSONUser_msg1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONUser8) -}
cd4dc0ec49f43090f0cba3b045d42693
  $fFromJSONUser_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONUser4) -}
244f31c3f81f1a705e107bf741b0644d
  $fFromJSONUser_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONUser2) -}
09d06bc2da79bac71de1c6ffe201e23a
  $fFromJSONUser_pathElem1 ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONUser5) -}
0885cf720f3e0d6e614af02df1c68367
  $fFromJSONView :: Data.Aeson.Types.FromJSON.FromJSON View.View
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.View
                  ProjectJson.$fFromJSONView_$cparseJSON
                  ProjectJson.$fFromJSONView_$cparseJSONList -}
03c1ad967dac42224f17429d4e9933cc
  $fFromJSONView1 ::
    [Data.Aeson.Types.Internal.Parser View.View]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.View] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
1024b65f1701e20de897d9434ac7a050
  $fFromJSONView10 :: Data.Aeson.Types.Internal.Parser View.View
  {- Strictness: x -}
9a14f125d7831ff18646850c27b443ac
  $fFromJSONView2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "rows"#) -}
337174d06db6abf0b3cbf54b8cf4a583
  $fFromJSONView3 ::
    [Data.Aeson.Types.Internal.Parser View.ViewRow]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewRow] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
4490c60357243fb84d1590abf4e02b21
  $fFromJSONView4 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [View.ViewRow] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success [View.ViewRow] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONView_msg3) -}
31251ff8b1e086b26f245d691b0cb012
  $fFromJSONView5 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONView2 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
9f0d15b30122eaef306d12ec663abd52
  $fFromJSONView6 :: Data.Aeson.Types.Internal.Parser View.ViewName
  {- Strictness: x -}
9833b59dca086bdadacd9be59016adc6
  $fFromJSONView7 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success View.ViewName f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success View.ViewName f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONView_msg1) -}
fd676bfba8b1e9d65cb664c2bf31c06a
  $fFromJSONView8 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONView9 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
91cbb44965b65301d8955ba7a531c134
  $fFromJSONView9 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "name"#) -}
ffd1e00c68f0f16ce659a5afb50ef033
  $fFromJSONViewItem ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewItem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewItem
                  ProjectJson.$fFromJSONViewItem_$cparseJSON
                  ProjectJson.$fFromJSONViewItem_$cparseJSONList -}
93e244ba5be2fe4dc56f3de224738e1e
  $fFromJSONViewItem1 ::
    [Data.Aeson.Types.Internal.Parser View.ViewItem]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewItem] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
35d4d010ad8dda78b43e2918341897a7
  $fFromJSONViewItem_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewItem
  {- Arity: 1, Strictness: <S,1*U> -}
3b5974ddd97e1a37428461e6dcc86b88
  $fFromJSONViewItem_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewItem]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewItem]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONViewItem1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONViewItem_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewItem]>_R)) } }) -}
f199abcdfa24ed5e22a88b3c1ebdcd9b
  $fFromJSONViewItem_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewItem]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
1f4439c718a429e87bc4574904cfd16c
  $fFromJSONViewLabel ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewLabel
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewLabel
                  ProjectJson.$fFromJSONViewLabel_$cparseJSON
                  ProjectJson.$fFromJSONViewLabel_$cparseJSONList -}
4a58e84c834e0af4c96221b565c1c876
  $fFromJSONViewLabel1 ::
    [Data.Aeson.Types.Internal.Parser View.ViewLabel]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewLabel] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
205d3817717cf531d07ee0711fbff3da
  $fFromJSONViewLabel2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success View.ViewLabel f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success View.ViewLabel f r) ->
                 case ds of wild {
                   DEFAULT -> case ProjectJson.$fFromJSONViewLabel3 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (View.N:ViewLabel[0])) }) -}
788298fc18ce46ca20e6cdd55f60755a
  $fFromJSONViewLabel3 ::
    Data.Aeson.Types.Internal.Parser View.ViewLabel
  {- Strictness: x -}
109854f5a62a5cdd9a76636d09ca80a4
  $fFromJSONViewLabel_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewLabel
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONViewLabel2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <View.ViewLabel>_R)) -}
ac54427f5dda5db8dc23e96519db1da2
  $fFromJSONViewLabel_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewLabel]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewLabel]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONViewLabel1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONViewLabel_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewLabel]>_R)) } }) -}
0b4a40fc05fca42f0af9dd85a1f1d7a6
  $fFromJSONViewLabel_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewLabel]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
c8f80f6e52fa066ec0d8ad39bbe7e439
  $fFromJSONViewName ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewName
                  ProjectJson.$fFromJSONViewName_$cparseJSON
                  ProjectJson.$fFromJSONViewName_$cparseJSONList -}
789cf76aadff1af22b634934fe644570
  $fFromJSONViewName1 ::
    [Data.Aeson.Types.Internal.Parser View.ViewName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
0e0bf94147970d53772149094bf3c3cf
  $fFromJSONViewName2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success View.ViewName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success View.ViewName f r) ->
                 case ds of wild {
                   DEFAULT -> case ProjectJson.$fFromJSONView6 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (View.N:ViewName[0])) }) -}
7c9f6e37cd6342a5baf0c32aab293f63
  $fFromJSONViewName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewName
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONViewName2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <View.ViewName>_R)) -}
a88abf67c02b04e811e950dd2e6c58b3
  $fFromJSONViewName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONViewName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONViewName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewName]>_R)) } }) -}
bdb160de04c357d2cc9ea0f88b380c37
  $fFromJSONViewName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewName]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
1337a67c44e741a638b150b1dd639eff
  $fFromJSONViewRow ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewRow
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewRow
                  ProjectJson.$fFromJSONViewRow_$cparseJSON
                  ProjectJson.$fFromJSONView_$cparseJSONList1 -}
dc9c7642f8bba64f39956eda804db1f8
  $fFromJSONViewRow1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "items"#) -}
703c990d4e743a3966ba72b934b6f8d5
  $fFromJSONViewRow2 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [View.ViewItem] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success [View.ViewItem] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONViewRow_msg3) -}
bf38bc849ade9c1abab0f4cda43bc263
  $fFromJSONViewRow3 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONViewRow1 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONAllProjects7 }) -}
a8085d3a2ce5e944885787ea8a01e8a6
  $fFromJSONViewRow4 :: Data.Aeson.Types.Internal.Parser View.ViewRow
  {- Strictness: x -}
58e437213d94ef05ff86c917da6b424f
  $fFromJSONViewRow_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewRow
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT -> ProjectJson.$fFromJSONViewRow4
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser [View.ViewItem]
                        = case ProjectJson.$fFromJSONViewRow1 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONViewRow2
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewItem]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [View.ViewItem]
                                 = ProjectJson.$fFromJSONViewItem_$cparseJSONList v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success [View.ViewItem] f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewItem]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONViewRow_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[View.ViewItem]>_R)) } }
                      } in
                      (\ @ (f22 :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f22 r)
                         (ks :: Data.Aeson.Types.Internal.Success View.ViewRow f22 r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewItem]>_R)
                         @ f22
                         @ r
                         path
                         kf
                         (\ (a2 :: [View.ViewItem]) ->
                          ks a2 `cast` (Sym (View.N:ViewRow[0]))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <View.ViewRow>_R)) }) -}
4d8868f9a27d0512de868bf48ecd52b3
  $fFromJSONViewRow_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONViewRow3) -}
f861bf2e459e555bc6562b3224e5fb60
  $fFromJSONViewRow_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONViewRow1) -}
6080220b396aad17075bcfc07e59ffd9
  $fFromJSONView_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.View
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT -> ProjectJson.$fFromJSONView10
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser View.ViewName
                        = case ProjectJson.$fFromJSONView9 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONView7
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <View.ViewName>_R))
                            GHC.Base.Just v1
                            -> (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success View.ViewName f r) ->
                                case v1 of wild2 {
                                  DEFAULT -> case ProjectJson.$fFromJSONView6 ret_ty (f r) of {}
                                  Data.Aeson.Types.Internal.String v2
                                  -> ks v2 `cast` (Sym (View.N:ViewName[0])) })
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <View.ViewName>_R)) } }
                      } in
                      let {
                        e :: Data.Aeson.Types.Internal.Parser [View.ViewRow]
                        = case ProjectJson.$fFromJSONView2 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONView4
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewRow]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [View.ViewRow]
                                 = ProjectJson.$fFromJSONView_$cparseJSONList1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success [View.ViewRow] f r) ->
                                p `cast` (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewRow]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONView_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[View.ViewRow]>_R)) } }
                      } in
                      (\ @ (f :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f r)
                         (ks :: Data.Aeson.Types.Internal.Success View.View f r) ->
                       m `cast` (Data.Aeson.Types.Internal.N:Parser[0] <View.ViewName>_R)
                         @ f
                         @ r
                         path
                         kf
                         (\ (a2 :: View.ViewName) ->
                          e `cast` (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewRow]>_R)
                            @ f
                            @ r
                            path
                            kf
                            (\ (a3 :: [View.ViewRow]) -> ks (View.View a2 a3))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0] <View.View>_R)) }) -}
61a5cac4e60ad6e26059e9ea0866a3f3
  $fFromJSONView_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.View]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.View]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONView1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONView_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.View]>_R)) } }) -}
689cfef6fb3add49ee3f0385d1fa04cc
  $fFromJSONView_$cparseJSONList1 ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewRow]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewRow]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONView3
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONView_go1 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewRow]>_R)) } }) -}
1c1f847e1944b0516a06c9896e608b19
  $fFromJSONView_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.View]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
94a5800470ac28f326e9f1e61b341624
  $fFromJSONView_go1 ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewRow]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
d9e7c3d6aeb9bbd124081df496b1f3e1
  $fFromJSONView_msg1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONView8) -}
15924364e87be5b2aef7e48bce85cae2
  $fFromJSONView_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONView5) -}
f0e7b6d185a573289b7ec62d54f10bc8
  $fFromJSONView_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONView2) -}
a42e52fa6ad2415d65cfdeab4285ed91
  $fFromJSONXFormula ::
    Data.Aeson.Types.FromJSON.FromJSON Formula.XFormula
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Formula.XFormula
                  ProjectJson.$fFromJSONXFormula_$cparseJSON
                  ProjectJson.$fFromJSONXFormula_$cparseJSONList -}
8161189f281a5c41abdda313633861ae
  $fFromJSONXFormula1 ::
    [Data.Aeson.Types.Internal.Parser Formula.XFormula]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Formula.XFormula] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
ff0ec5156a6c8cba5fadd216415b57aa
  $fFromJSONXFormula_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Formula.XFormula
  {- Arity: 1, Strictness: <S,1*U> -}
e465cc342f8dcb4cacb9c94ae0c6fa95
  $fFromJSONXFormula_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Formula.XFormula]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Formula.XFormula]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONXFormula1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONXFormula_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Formula.XFormula]>_R)) } }) -}
25466442deb43182ffa27f3c48c57efe
  $fFromJSONXFormula_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Formula.XFormula]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
5e2794f76108c099b62388dd2cf15b65
  $fFromJSONXMap :: Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMap
                  ProjectJson.$fFromJSONXMap_$cparseJSON
                  ProjectJson.$fFromJSONXMap_$cparseJSONList -}
dc9b39dbddab616b0c89273c2d701cb5
  $fFromJSONXMap1 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XMap]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XMap] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
76b5970c9aa4486229a217fbfe5c92c8
  $fFromJSONXMapKey ::
    Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XMapKey
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapKey
                  ProjectJson.$fFromJSONXMapKey_$cparseJSON
                  ProjectJson.$fFromJSONXMapKey_$cparseJSONList -}
a3f49c4fb021722f1bcf551e261bea01
  $fFromJSONXMapKey1 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XMapKey] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
53e1c7215ac2fb03e06772527daae5fb
  $fFromJSONXMapKey2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success XMapTypes.XMapKey f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              XMapTypes.XMapKey f r) ->
                 case ds of wild {
                   DEFAULT -> case ProjectJson.$fFromJSONXMapKey3 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (XMapTypes.N:XMapKey[0])) }) -}
7c371ff0e07c9044a9a7f1b8286023d4
  $fFromJSONXMapKey3 ::
    Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey
  {- Strictness: x -}
dad664ef960e56ac04579c2b58bc763f
  $fFromJSONXMapKey_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONXMapKey2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <XMapTypes.XMapKey>_R)) -}
e6793e6459bb43ab5b1de4c57e26b86c
  $fFromJSONXMapKey_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XMapKey]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XMapKey]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONXMapKey1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONXMapKey_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XMapKey]>_R)) } }) -}
99682239d79dd0244fa78ec110a352d2
  $fFromJSONXMapKey_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
011fb8788ac227ff21c41e0c1d10b6ef
  $fFromJSONXMapName ::
    Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XMapName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapName
                  ProjectJson.$fFromJSONXMapName_$cparseJSON
                  ProjectJson.$fFromJSONSource_$cparseJSONList1 -}
2e6715fbba0503c9092b89d267366e8e
  $fFromJSONXMapName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XMapName
  {- Arity: 1, Strictness: <S,1*U> -}
298e67c613633866e2429b891f2c3bc7
  $fFromJSONXMap_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XMap
  {- Arity: 1, Strictness: <S,1*U> -}
04a093fbc1cfd4be00ad4ea693f17976
  $fFromJSONXMap_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XMap]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XMap]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONXMap1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONXMap_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XMap]>_R)) } }) -}
c56c9b59f3ea8ba7c44f6a909b2ecde7
  $fFromJSONXMap_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XMap]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
70c3555d1dda6f091486ed8a75fdb316
  $fFromJSONXNamedMap ::
    Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XNamedMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XNamedMap
                  ProjectJson.$fFromJSONXNamedMap_$cparseJSON
                  ProjectJson.$fFromJSONXNamedMap_$cparseJSONList -}
b5076a0f7b58bc46fc426c6a85e4baba
  $fFromJSONXNamedMap1 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XNamedMap]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XNamedMap] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
59e6cd2ab70b486b0d6e1dd8f1411d2f
  $fFromJSONXNamedMap_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XNamedMap
  {- Arity: 1, Strictness: <S,1*U> -}
fcf160770e5539cc12d644421d272bf1
  $fFromJSONXNamedMap_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XNamedMap]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XNamedMap]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONXNamedMap1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONXNamedMap_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XNamedMap]>_R)) } }) -}
89a70d8e82b8cd14cc4149a9742348ca
  $fFromJSONXNamedMap_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XNamedMap]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
9d88253c92c9355d7bca71222bfc6c1e
  $fToJSONAllProjects ::
    Data.Aeson.Types.ToJSON.ToJSON Project.AllProjects
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.AllProjects
                  ProjectJson.$fToJSONAllProjects_$ctoJSON
                  ProjectJson.$fToJSONAllProjects_$ctoEncoding
                  ProjectJson.$fToJSONAllProjects_$ctoJSONList
                  ProjectJson.$fToJSONAllProjects_$ctoEncodingList -}
e337084bf43edab5e322159307fa30dd
  $fToJSONAllProjects1 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
2518f7c1afab8c0b423418e11028b75f
  $fToJSONAllProjects2 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
493296a2c80969b9ee667eaf89930978
  $fToJSONAllProjects_$ctoEncoding ::
    Project.AllProjects -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <L,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.AllProjects) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONAllProjects_$ctoJSON eta)) -}
db3e775646f8c9fc691c8d46b03f1350
  $fToJSONAllProjects_$ctoEncodingList ::
    [Project.AllProjects] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.AllProjects]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONAllProjects_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.AllProjects
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.AllProjects)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONAllProjects_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.AllProjects>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
b2e0aa548a3a306268543d733bdc3ae4
  $fToJSONAllProjects_$ctoJSON ::
    Project.AllProjects -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <L,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.AllProjects) ->
                 case ProjectJson.$w$ctoJSON w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
20293deaa33482a63bdb21ca4fbc0be4
  $fToJSONAllProjects_$ctoJSONList ::
    [Project.AllProjects] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.AllProjects]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.AllProjects
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.AllProjects
                                       c
                                       ProjectJson.$fToJSONAllProjects_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
4ad8f69e92a6080ed14496a80b18e77b
  $fToJSONApplicationName ::
    Data.Aeson.Types.ToJSON.ToJSON ApplicationTypes.ApplicationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ApplicationTypes.ApplicationName
                  ProjectJson.$fToJSONApplicationName_$ctoJSON
                  ProjectJson.$fToJSONApplicationName_$ctoEncoding
                  ProjectJson.$fToJSONApplicationName_$ctoJSONList
                  ProjectJson.$fToJSONApplicationName_$ctoEncodingList -}
dc9cbb2ada104b8d7cef9b6c883c42fa
  $fToJSONApplicationName_$ctoEncoding ::
    ApplicationTypes.ApplicationName
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*H>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: ApplicationTypes.ApplicationName) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONApplicationName_$ctoJSON eta)) -}
87780ea163fac19660a10933485e23a2
  $fToJSONApplicationName_$ctoEncodingList ::
    [ApplicationTypes.ApplicationName]
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [ApplicationTypes.ApplicationName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONApplicationName_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ ApplicationTypes.ApplicationName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: ApplicationTypes.ApplicationName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONApplicationName_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<ApplicationTypes.ApplicationName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
f6f380576af243156d1dc76ef3334455
  $fToJSONApplicationName_$ctoJSON ::
    ApplicationTypes.ApplicationName -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*H>m3, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ApplicationTypes.ApplicationName) ->
                 case w of w1 { ApplicationTypes.Negate ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ Data.Text.Internal.Text
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds9 { (#,#) ipv ipv1 ->
                         TextEnums.$wouter
                           ipv1
                           4#
                           ApplicationTypes.$fReadApplicationName4
                           0#
                           ipv }) of ds9 { (#,#) ipv ipv1 ->
                 case ipv1 of dt { Data.Text.Internal.Text ipv2 ipv3 ipv4 ->
                 Data.Aeson.Types.Internal.String dt } } }) -}
b289bf22d78a1bd8443edf13217aec1c
  $fToJSONApplicationName_$ctoJSONList ::
    [ApplicationTypes.ApplicationName]
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [ApplicationTypes.ApplicationName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ ApplicationTypes.ApplicationName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ ApplicationTypes.ApplicationName
                                       c
                                       ProjectJson.$fToJSONApplicationName_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
82667a8c9d334562523e1fb241484f94
  $fToJSONCalculation ::
    Data.Aeson.Types.ToJSON.ToJSON Project.Calculation
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Calculation
                  ProjectJson.$fToJSONCalculation_$ctoJSON
                  ProjectJson.$fToJSONCalculation_$ctoEncoding
                  ProjectJson.$fToJSONCalculation_$ctoJSONList
                  ProjectJson.$fToJSONCalculation_$ctoEncodingList -}
eb01d84d82b1bcb32b3d57b5da418152
  $fToJSONCalculation1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "operationMode"#) -}
a71d118b0aa62b3cc6b15ec1ce9ffce2
  $fToJSONCalculation2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "formula"#) -}
4fd4f4484fc9ac45a48b0048d840e066
  $fToJSONCalculation3 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "/"#) -}
9fbf7e23f4b3b29c00b8cd464fa1a881
  $fToJSONCalculation4 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "resultName"#) -}
cb1a463a33bf9dc04062c28d3b9e13ad
  $fToJSONCalculation_$ctoEncoding ::
    Project.Calculation -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.Calculation) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculation_$ctoJSON eta)) -}
1f63b4965477232d29f70485d9591344
  $fToJSONCalculation_$ctoEncodingList ::
    [Project.Calculation] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Calculation]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculation_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.Calculation
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.Calculation)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculation_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.Calculation>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
cddd1e050f8a036eb4fe10380dbab48c
  $fToJSONCalculation_$ctoJSON ::
    Project.Calculation -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.Calculation) ->
                 case w of ww { Project.Calculation ww1 ww2 ww3 ->
                 case ProjectJson.$w$ctoJSON1 ww1 ww2 ww3 of ww4 { Unit# ww5 ->
                 Data.Aeson.Types.Internal.Object ww5 } }) -}
30c95a491a5b6e9e2ad0caf0896cba9e
  $fToJSONCalculation_$ctoJSON1 ::
    XFunction.OperationMode -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m3, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: XFunction.OperationMode) ->
                 case ProjectJson.$w$ctoJSON2 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.String ww1 }) -}
f6c7730ec6f5fd0824adf08be814d9fc
  $fToJSONCalculation_$ctoJSON2 ::
    Formula.XFormula -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Formula.XFormula) ->
                 case ProjectJson.$w$ctoJSON3 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
00492f421a007ae24832a71461778d97
  $fToJSONCalculation_$ctoJSON3 ::
    XMapTypes.XMapName -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m3,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: XMapTypes.XMapName) ->
                 case Data.Text.concat
                        (Data.Text.Internal.Functions.intersperse
                           @ Data.Text.Internal.Text
                           ProjectJson.$fToJSONCalculation3
                           ds
                             `cast`
                           (XMapTypes.N:XMapName[0])) of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
ddfdd269a8ef8f0250847749188da82c
  $fToJSONCalculation_$ctoJSONList ::
    [Project.Calculation] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Calculation]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.Calculation
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.Calculation
                                       c
                                       ProjectJson.$fToJSONCalculation_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
34b99ee46eed8f37553fee4bb162a8c6
  $fToJSONOperationMode ::
    Data.Aeson.Types.ToJSON.ToJSON XFunction.OperationMode
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XFunction.OperationMode
                  ProjectJson.$fToJSONCalculation_$ctoJSON1
                  ProjectJson.$fToJSONOperationMode_$ctoEncoding
                  ProjectJson.$fToJSONOperationMode_$ctoJSONList
                  ProjectJson.$fToJSONOperationMode_$ctoEncodingList -}
179fb50eb539844aef54f327cb3da7e2
  $fToJSONOperationMode_$ctoEncoding ::
    XFunction.OperationMode -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XFunction.OperationMode) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculation_$ctoJSON1 eta)) -}
f93f9807f26487f2a93e9f5d303d2c2a
  $fToJSONOperationMode_$ctoEncodingList ::
    [XFunction.OperationMode] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XFunction.OperationMode]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculation_$ctoJSON1 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XFunction.OperationMode
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XFunction.OperationMode)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculation_$ctoJSON1 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XFunction.OperationMode>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
fd6384ff26b4580071a755edff539914
  $fToJSONOperationMode_$ctoJSONList ::
    [XFunction.OperationMode] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XFunction.OperationMode]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XFunction.OperationMode
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XFunction.OperationMode
                                       c
                                       ProjectJson.$fToJSONCalculation_$ctoJSON1)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
865905a81949a24cbb039a89c2c63375
  $fToJSONOperationName ::
    Data.Aeson.Types.ToJSON.ToJSON OperationTypes.OperationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ OperationTypes.OperationName
                  ProjectJson.$fToJSONOperationName_$ctoJSON
                  ProjectJson.$fToJSONOperationName_$ctoEncoding
                  ProjectJson.$fToJSONOperationName_$ctoJSONList
                  ProjectJson.$fToJSONOperationName_$ctoEncodingList -}
0b85647b7d052326c1f2f732640b5d94
  $fToJSONOperationName_$ctoEncoding ::
    OperationTypes.OperationName
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: OperationTypes.OperationName) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONOperationName_$ctoJSON eta)) -}
dc48dee5572767f886680b22ae002ffe
  $fToJSONOperationName_$ctoEncodingList ::
    [OperationTypes.OperationName]
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [OperationTypes.OperationName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONOperationName_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ OperationTypes.OperationName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: OperationTypes.OperationName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONOperationName_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<OperationTypes.OperationName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
ab0c114d1c982d117bd8d0d612c5b882
  $fToJSONOperationName_$ctoJSON ::
    OperationTypes.OperationName -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m3, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: OperationTypes.OperationName) ->
                 case ProjectJson.$w$ctoJSON4 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.String ww1 }) -}
31b4f60bbdba1dd3ec5dff8bdedf8dca
  $fToJSONOperationName_$ctoJSONList ::
    [OperationTypes.OperationName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [OperationTypes.OperationName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ OperationTypes.OperationName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ OperationTypes.OperationName
                                       c
                                       ProjectJson.$fToJSONOperationName_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
846e78feb08b312576787e043593ec18
  $fToJSONProject :: Data.Aeson.Types.ToJSON.ToJSON Project.Project
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Project
                  ProjectJson.$fToJSONProject_$ctoJSON
                  ProjectJson.$fToJSONProject_$ctoEncoding
                  ProjectJson.$fToJSONProject_$ctoJSONList
                  ProjectJson.$fToJSONProject_$ctoEncodingList -}
92577a85bda7eb8935dcba065a517c4e
  $fToJSONProjectName ::
    Data.Aeson.Types.ToJSON.ToJSON Project.ProjectName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.ProjectName
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (Project.N:ProjectName[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: Project.ProjectName) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (Project.N:ProjectName[0])))
                  ProjectJson.$fToJSONProjectName_$ctoJSONList
                  ProjectJson.$fToJSONProjectName_$ctoEncodingList -}
e20b3469505a5aa782f8220ca65594ed
  $fToJSONProjectName_$ctoEncodingList ::
    [Project.ProjectName] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.ProjectName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (Project.N:ProjectName[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.ProjectName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.ProjectName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (Project.N:ProjectName[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.ProjectName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
ed98ae3d474978b027a890948abe06a7
  $fToJSONProjectName_$ctoJSONList ::
    [Project.ProjectName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.ProjectName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.ProjectName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.ProjectName
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (Project.N:ProjectName[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
34ca70f4bf33f38034a1c3ab37787d35
  $fToJSONProject_$ctoEncoding ::
    Project.Project -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.Project) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONProject_$ctoJSON eta)) -}
54c1b52a46848a62d80a0044f0b0a002
  $fToJSONProject_$ctoEncodingList ::
    [Project.Project] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Project]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONProject_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.Project
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.Project)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONProject_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.Project>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
14461e522e0b10a5c2e8750cb263ef75
  $fToJSONProject_$ctoJSON ::
    Project.Project -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>m1,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.Project) ->
                 case w of ww { Project.Project ww1 ww2 ww3 ww4 ->
                 case ProjectJson.$w$ctoJSON5 ww1 ww2 ww3 ww4 of ww5 { Unit# ww6 ->
                 Data.Aeson.Types.Internal.Object ww6 } }) -}
b72295c5ce3d10aa15be25fd35d4c3dc
  $fToJSONProject_$ctoJSONList ::
    [Project.Project] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Project]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.Project
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.Project
                                       c
                                       ProjectJson.$fToJSONProject_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
4142097eac597196dacca58e8f3f7cb1
  $fToJSONSource :: Data.Aeson.Types.ToJSON.ToJSON Project.Source
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Source
                  ProjectJson.$fToJSONSource_$ctoJSON
                  ProjectJson.$fToJSONSource_$ctoEncoding
                  ProjectJson.$fToJSONSource_$ctoJSONList
                  ProjectJson.$fToJSONSource_$ctoEncodingList -}
28ca6db24a6ac1288350f2785746e0ed
  $fToJSONSource1 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
eb34c9e812eb7032bec4ca4e381c0d61
  $fToJSONSource10 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        ProjectJson.$fToJSONSource11
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 Data.Aeson.Types.Internal.Object dt }) -}
210f2e27638ad6ee4398b6ee399fb684
  $fToJSONSource11 :: [Data.Aeson.Types.Internal.Pair]
  {- Unfolding: (GHC.Types.:
                   @ Data.Aeson.Types.Internal.Pair
                   ProjectJson.$fToJSONSource12
                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)) -}
fe1d90cc143f109cfebdc9c04f0da775
  $fToJSONSource12 ::
    (Data.Text.Internal.Text, Data.Aeson.Types.Internal.Value)
  {- Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONSource13)) -}
b2bd585e2f67eb79361a69a2c3d2ac67
  $fToJSONSource13 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "internalSource"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
34552917502fcf32dda91da1f2d0c375
  $fToJSONSource2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "url"#) -}
4b934d16ea3fcf4aea3de6e562a5bed4
  $fToJSONSource3 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONSource4)) -}
d4e613556a4ac3f06844ffc6320e1dae
  $fToJSONSource4 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "httpSource"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
21e279de3e4c7a918e9114d2cb765d84
  $fToJSONSource5 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "type"#) -}
e75b3adc54153868b133580fad94cefc
  $fToJSONSource6 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "sqlQuery"#) -}
7a63d3ca640611de30f4d6548aab5110
  $fToJSONSource7 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   "connectionString"#) -}
599d770003a9da4e886a55cd3086cf4f
  $fToJSONSource8 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONSource9)) -}
e0c173416266cc8ec0cab243791a9e3c
  $fToJSONSource9 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "odbcSource"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
c4b514159f9c029befd18e7aaf271611
  $fToJSONSourceType ::
    Data.Aeson.Types.ToJSON.ToJSON Project.SourceType
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.SourceType
                  ProjectJson.$fToJSONSource_$ctoJSON1
                  ProjectJson.$fToJSONSourceType_$ctoEncoding
                  ProjectJson.$fToJSONSourceType_$ctoJSONList
                  ProjectJson.$fToJSONSourceType_$ctoEncodingList -}
fe42f39f574eae96748f74962e02faf5
  $fToJSONSourceType_$ctoEncoding ::
    Project.SourceType -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.SourceType) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONSource_$ctoJSON1 eta)) -}
dca10d4e7ffc145d5ffcb88853b85fcc
  $fToJSONSourceType_$ctoEncodingList ::
    [Project.SourceType] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.SourceType]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONSource_$ctoJSON1 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.SourceType
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.SourceType)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONSource_$ctoJSON1 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.SourceType>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
6e45cfe9c173820465abb436f1c54550
  $fToJSONSourceType_$ctoJSONList ::
    [Project.SourceType] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.SourceType]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.SourceType
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.SourceType
                                       c
                                       ProjectJson.$fToJSONSource_$ctoJSON1)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
e3f1d774b0967415049c14dc4fe005cf
  $fToJSONSource_$ctoEncoding ::
    Project.Source -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.Source) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONSource_$ctoJSON eta)) -}
11f3b566d8442feea0416399b2c350b7
  $fToJSONSource_$ctoEncodingList ::
    [Project.Source] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Source]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONSource_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.Source
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.Source)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONSource_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.Source>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
526c54598e3faf39c603b7a844dcbce4
  $fToJSONSource_$ctoJSON ::
    Project.Source -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.Source) ->
                 case w of ww { Project.Source ww1 ww2 ->
                 case ProjectJson.$w$ctoJSON6 ww1 ww2 of ww3 { Unit# ww4 ->
                 Data.Aeson.Types.Internal.Object ww4 } }) -}
1f1244247699e78beb64811413dd9c6e
  $fToJSONSource_$ctoJSON1 ::
    Project.SourceType -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Project.SourceType) ->
                 case ds of wild {
                   Project.InternalSource -> ProjectJson.$fToJSONSource10
                   Project.OdbcSource connectionString sqlQuery
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONSource8
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONSource7,
                                    Data.Aeson.Types.Internal.$WString connectionString)
                                   (GHC.Types.:
                                      @ Data.Aeson.Types.Internal.Pair
                                      (ProjectJson.$fToJSONSource6,
                                       Data.Aeson.Types.Internal.$WString sqlQuery)
                                      (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair))))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      Data.Aeson.Types.Internal.Object dt }
                   Project.HttpSource url
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONSource3
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONSource2,
                                    Data.Aeson.Types.Internal.$WString url)
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      Data.Aeson.Types.Internal.Object dt } }) -}
faea63c2a8781cc6087c36d748d14e9a
  $fToJSONSource_$ctoJSONList ::
    [Project.Source] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Source]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.Source
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.Source
                                       c
                                       ProjectJson.$fToJSONSource_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
38899610c766263c08bbfb5509099c4d
  $fToJSONUser :: Data.Aeson.Types.ToJSON.ToJSON Project.User
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.User
                  ProjectJson.$fToJSONUser_$ctoJSON
                  ProjectJson.$fToJSONUser_$ctoEncoding
                  ProjectJson.$fToJSONUser_$ctoJSONList
                  ProjectJson.$fToJSONUser_$ctoEncodingList -}
dcc204b8dd22c0b413c04ff792f75015
  $fToJSONUser1 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
7a3c85e2fd3b689b83b2890a71594a5a
  $fToJSONUser_$ctoEncoding ::
    Project.User -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.User) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONUser_$ctoJSON eta)) -}
2cb490c3184b814d1c61fa31fba4d0e2
  $fToJSONUser_$ctoEncodingList ::
    [Project.User] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.User]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONUser_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.User
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.User)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONUser_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.User>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
da08dbea0e2ab5a1415f30e423aadb3a
  $fToJSONUser_$ctoJSON ::
    Project.User -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.User) ->
                 case w of ww { Project.User ww1 ww2 ->
                 case ProjectJson.$w$ctoJSON7 ww1 ww2 of ww3 { Unit# ww4 ->
                 Data.Aeson.Types.Internal.Object ww4 } }) -}
d54437879a0f494d8fc053a2892e16f9
  $fToJSONUser_$ctoJSONList ::
    [Project.User] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.User]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.User
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.User
                                       c
                                       ProjectJson.$fToJSONUser_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
3dbf55495f4d27bed4674ba85ece1c47
  $fToJSONView :: Data.Aeson.Types.ToJSON.ToJSON View.View
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.View
                  ProjectJson.$fToJSONView_$ctoJSON
                  ProjectJson.$fToJSONView_$ctoEncoding
                  ProjectJson.$fToJSONView_$ctoJSONList
                  ProjectJson.$fToJSONView_$ctoEncodingList -}
1e4fb0dc458d6617a1d19c158d814c31
  $fToJSONView1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "label"#) -}
2c6af43e4476947acd3bbd6124f92437
  $fToJSONView2 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONView3)) -}
e6bd25682d87d21e3450fba2a65719f8
  $fToJSONView3 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "label"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
6118bca6ef9e2d9798c026cd9695a926
  $fToJSONView4 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "mapName"#) -}
489c7fec9d48c342e34fc062a9b04449
  $fToJSONView5 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONView6)) -}
875e1a6cfe27f54809923d35d0c75533
  $fToJSONView6 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "map"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
1de2396cf898419ad3a3296442ad56c3
  $fToJSONView7 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
3d3e7d6fe3df698bd4db2c1600d2d994
  $fToJSONView8 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
3f53068e5a2155a75e45d46165ca5288
  $fToJSONViewItem :: Data.Aeson.Types.ToJSON.ToJSON View.ViewItem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewItem
                  ProjectJson.$fToJSONView_$ctoJSON2
                  ProjectJson.$fToJSONViewItem_$ctoEncoding
                  ProjectJson.$fToJSONViewItem_$ctoJSONList
                  ProjectJson.$fToJSONViewItem_$ctoEncodingList -}
9e2b45ffda91311896c5ec8337d9c7d1
  $fToJSONViewItem_$ctoEncoding ::
    View.ViewItem -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: View.ViewItem) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONView_$ctoJSON2 eta)) -}
76967c5426d548dd874c45a773e3ad6a
  $fToJSONViewItem_$ctoEncodingList ::
    [View.ViewItem] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewItem]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONView_$ctoJSON2 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewItem
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewItem)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONView_$ctoJSON2 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewItem>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
0ee3bf1dea6fb7af75459270badb9c6f
  $fToJSONViewItem_$ctoJSONList ::
    [View.ViewItem] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewItem]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewItem
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewItem
                                       c
                                       ProjectJson.$fToJSONView_$ctoJSON2)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
b9df6455a21456ceb043dff883701758
  $fToJSONViewLabel :: Data.Aeson.Types.ToJSON.ToJSON View.ViewLabel
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewLabel
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (View.N:ViewLabel[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: View.ViewLabel) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (View.N:ViewLabel[0])))
                  ProjectJson.$fToJSONViewLabel_$ctoJSONList
                  ProjectJson.$fToJSONViewLabel_$ctoEncodingList -}
e8cf606af2dd85aa56b5adbb87ac88d4
  $fToJSONViewLabel_$ctoEncodingList ::
    [View.ViewLabel] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewLabel]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (View.N:ViewLabel[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewLabel
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewLabel)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (View.N:ViewLabel[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewLabel>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
6a713063135cff7667f5d895d5cbe1e8
  $fToJSONViewLabel_$ctoJSONList ::
    [View.ViewLabel] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewLabel]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewLabel
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewLabel
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (View.N:ViewLabel[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
5bb48244a0954c47145a66ec106fd223
  $fToJSONViewName :: Data.Aeson.Types.ToJSON.ToJSON View.ViewName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewName
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (View.N:ViewName[0]) ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: View.ViewName) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (View.N:ViewName[0])))
                  ProjectJson.$fToJSONViewName_$ctoJSONList
                  ProjectJson.$fToJSONViewName_$ctoEncodingList -}
0b80d32a5bc44811d0eb5a7a0718a995
  $fToJSONViewName_$ctoEncodingList ::
    [View.ViewName] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString x `cast` (View.N:ViewName[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (View.N:ViewName[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
b9964fda66ee586012fa9c9dbf14f44c
  $fToJSONViewName_$ctoJSONList ::
    [View.ViewName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewName
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (View.N:ViewName[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
80dc666c9ad5a1a5bd04ec3d361fd064
  $fToJSONViewRow :: Data.Aeson.Types.ToJSON.ToJSON View.ViewRow
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewRow
                  ProjectJson.$fToJSONView_$ctoJSON1
                  ProjectJson.$fToJSONViewRow_$ctoEncoding
                  ProjectJson.$fToJSONViewRow_$ctoJSONList
                  ProjectJson.$fToJSONViewRow_$ctoEncodingList -}
59278a98bff8af8a61274573150554d7
  $fToJSONViewRow_$ctoEncoding ::
    View.ViewRow -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <L,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: View.ViewRow) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONView_$ctoJSON1 eta)) -}
79ddd7629cb8dd19e27b4912a686b1cf
  $fToJSONViewRow_$ctoEncodingList ::
    [View.ViewRow] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewRow]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONView_$ctoJSON1 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewRow
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewRow)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONView_$ctoJSON1 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewRow>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
4346ef542bbc96b6ef4df8c6dd54e16f
  $fToJSONViewRow_$ctoJSONList ::
    [View.ViewRow] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewRow]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewRow
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewRow
                                       c
                                       ProjectJson.$fToJSONView_$ctoJSON1)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
4bdfc2f16675e871ce6adf89263ac148
  $fToJSONView_$ctoEncoding ::
    View.View -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: View.View) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONView_$ctoJSON eta)) -}
e355355efd62dee8a7fb9683dc2e3e1c
  $fToJSONView_$ctoEncodingList ::
    [View.View] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.View]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONView_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.View
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.View)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONView_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.View>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
541f5cc38b28db3a785bff668331eca2
  $fToJSONView_$ctoJSON ::
    View.View -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: View.View) ->
                 case w of ww { View.View ww1 ww2 ->
                 case ProjectJson.$w$ctoJSON8 ww1 ww2 of ww3 { Unit# ww4 ->
                 Data.Aeson.Types.Internal.Object ww4 } }) -}
8dcdd4291885354c5e4e01c3a07270f1
  $fToJSONView_$ctoJSON1 ::
    View.ViewRow -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <L,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: View.ViewRow) ->
                 case ProjectJson.$w$ctoJSON9 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
58a2c3a22a9a6e6ba425b9f1bef6f688
  $fToJSONView_$ctoJSON2 ::
    View.ViewItem -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: View.ViewItem) ->
                 case ProjectJson.$w$ctoJSON10 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
3a7d44fa55c49eb1c91a8519f3b9673c
  $fToJSONView_$ctoJSONList ::
    [View.View] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.View]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.View
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.View
                                       c
                                       ProjectJson.$fToJSONView_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
e44d191f3901d9d0f047412937e05c84
  $fToJSONXFormula :: Data.Aeson.Types.ToJSON.ToJSON Formula.XFormula
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Formula.XFormula
                  ProjectJson.$fToJSONCalculation_$ctoJSON2
                  ProjectJson.$fToJSONXFormula_$ctoEncoding
                  ProjectJson.$fToJSONXFormula_$ctoJSONList
                  ProjectJson.$fToJSONXFormula_$ctoEncodingList -}
4c82e276e4265f9fb897cac62e4226d0
  $fToJSONXFormula_$ctoEncoding ::
    Formula.XFormula -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Formula.XFormula) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculation_$ctoJSON2 eta)) -}
5b4dbaf5e517d0c655ffa0638afbca59
  $fToJSONXFormula_$ctoEncodingList ::
    [Formula.XFormula] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Formula.XFormula]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculation_$ctoJSON2 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Formula.XFormula
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Formula.XFormula)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculation_$ctoJSON2 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Formula.XFormula>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
194386481ca8621f528f823df3dfa026
  $fToJSONXFormula_$ctoJSONList ::
    [Formula.XFormula] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Formula.XFormula]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Formula.XFormula
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Formula.XFormula
                                       c
                                       ProjectJson.$fToJSONCalculation_$ctoJSON2)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
a1db2cfca96ecd4fe304eced591b9066
  $fToJSONXMap :: Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMap
                  ProjectJson.$fToJSONXMap_$ctoJSON
                  ProjectJson.$fToJSONXMap_$ctoEncoding
                  ProjectJson.$fToJSONXMap_$ctoJSONList
                  ProjectJson.$fToJSONXMap_$ctoEncodingList -}
6af96fae695c20977f2604dabcad4da1
  $fToJSONXMapKey :: Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XMapKey
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapKey
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (XMapTypes.N:XMapKey[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: XMapTypes.XMapKey) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (XMapTypes.N:XMapKey[0])))
                  ProjectJson.$fToJSONXMapKey_$ctoJSONList
                  ProjectJson.$fToJSONXMapKey_$ctoEncodingList -}
a73c7b5d37285cbee3cbe1d1ef7283bc
  $fToJSONXMapKey_$ctoEncodingList ::
    [XMapTypes.XMapKey] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapKey]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (XMapTypes.N:XMapKey[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XMapKey
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XMapKey)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (XMapTypes.N:XMapKey[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XMapKey>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
8c9e1b6f0d9f74996b48c8920f93f808
  $fToJSONXMapKey_$ctoJSONList ::
    [XMapTypes.XMapKey] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapKey]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XMapKey
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XMapKey
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (XMapTypes.N:XMapKey[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
0a1c68e366ddece2f7f1c28eaeb3de6d
  $fToJSONXMapName ::
    Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XMapName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapName
                  ProjectJson.$fToJSONCalculation_$ctoJSON3
                  ProjectJson.$fToJSONXMapName_$ctoEncoding
                  ProjectJson.$fToJSONXMapName_$ctoJSONList
                  ProjectJson.$fToJSONXMapName_$ctoEncodingList -}
93283675f2fa9fb441f5055b1e2c8bff
  $fToJSONXMapName_$ctoEncoding ::
    XMapTypes.XMapName -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XMapTypes.XMapName) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculation_$ctoJSON3 eta)) -}
931aa076b7b058d7a376672777d47f1c
  $fToJSONXMapName_$ctoEncodingList ::
    [XMapTypes.XMapName] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculation_$ctoJSON3 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XMapName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XMapName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculation_$ctoJSON3 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XMapName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
572997242017b4a42956d37021d6d0eb
  $fToJSONXMapName_$ctoJSONList ::
    [XMapTypes.XMapName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XMapName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XMapName
                                       c
                                       ProjectJson.$fToJSONCalculation_$ctoJSON3)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
359d47085344ebef5a7a4203d7d23a46
  $fToJSONXMap_$ctoEncoding ::
    XMapTypes.XMap -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XMapTypes.XMap) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONXMap_$ctoJSON eta)) -}
92deb58cf990eedf027035ae6ff5bc60
  $fToJSONXMap_$ctoEncodingList ::
    [XMapTypes.XMap] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMap]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONXMap_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XMap
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XMap)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONXMap_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XMap>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
2a1e7845c89fd04cd77f9809ac664e8f
  $fToJSONXMap_$ctoJSON ::
    XMapTypes.XMap -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: XMapTypes.XMap) ->
                 case ProjectJson.$w$ctoJSON11 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
812ecfbca46ee9f9739498034b237768
  $fToJSONXMap_$ctoJSONList ::
    [XMapTypes.XMap] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMap]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XMap
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XMap
                                       c
                                       ProjectJson.$fToJSONXMap_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
48708e7f96a6f042e88e12bec72c7b88
  $fToJSONXNamedMap ::
    Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XNamedMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XNamedMap
                  ProjectJson.$fToJSONXNamedMap_$ctoJSON
                  ProjectJson.$fToJSONXNamedMap_$ctoEncoding
                  ProjectJson.$fToJSONXNamedMap_$ctoJSONList
                  ProjectJson.$fToJSONXNamedMap_$ctoEncodingList -}
f1890056bdbad299ebf29924a165b8aa
  $fToJSONXNamedMap1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "xmap"#) -}
a2c51c4b4d6b89a01f25c50328dbfc14
  $fToJSONXNamedMap_$ctoEncoding ::
    XMapTypes.XNamedMap -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XMapTypes.XNamedMap) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONXNamedMap_$ctoJSON eta)) -}
b4f245e04c57f982e797646e3b111312
  $fToJSONXNamedMap_$ctoEncodingList ::
    [XMapTypes.XNamedMap] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XNamedMap]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONXNamedMap_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XNamedMap
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XNamedMap)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONXNamedMap_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XNamedMap>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
b147bd950a4465bb4a950c1f27bec30a
  $fToJSONXNamedMap_$ctoJSON ::
    XMapTypes.XNamedMap -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: XMapTypes.XNamedMap) ->
                 case w of ww { XMapTypes.XNamedMap ww1 ww2 ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fToJSONView4,
                            ProjectJson.$fToJSONCalculation_$ctoJSON3 ww1)
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fToJSONXNamedMap1,
                               ProjectJson.$fToJSONXMap_$ctoJSON ww2)
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 Data.Aeson.Types.Internal.Object dt } }) -}
320c92799e75af26f8ba747242e2a119
  $fToJSONXNamedMap_$ctoJSONList ::
    [XMapTypes.XNamedMap] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XNamedMap]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XNamedMap
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XNamedMap
                                       c
                                       ProjectJson.$fToJSONXNamedMap_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
c6f0e7de2b0d02cf8f85a054bad978a4
  $sfromList ::
    [(XMapTypes.XMapKey, a)] -> Data.Map.Base.Map XMapTypes.XMapKey a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [(XMapTypes.XMapKey, a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ XMapTypes.XMapKey @ a
                   : ds9 ds10
                   -> case ds9 of wild1 { (,) kx x ->
                      case ds10 of wild2 {
                        []
                        -> case x of x1 { DEFAULT ->
                           case kx
                                  `cast`
                                (XMapTypes.N:XMapKey[0]) of nt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                           Data.Map.Base.Bin
                             @ XMapTypes.XMapKey
                             @ a
                             1#
                             nt `cast` (Sym (XMapTypes.N:XMapKey[0]))
                             x1
                             (Data.Map.Base.Tip @ XMapTypes.XMapKey @ a)
                             (Data.Map.Base.Tip @ XMapTypes.XMapKey @ a) } }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds11 ->
                           case kx
                                  `cast`
                                (XMapTypes.N:XMapKey[0]) of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                           case ky
                                  `cast`
                                (XMapTypes.N:XMapKey[0]) of ww4 { Data.Text.Internal.Text ww5 ww6 ww7 ->
                           case Data.Text.$w$ccompare ww1 ww2 ww3 ww5 ww6 ww7 of wild4 {
                             DEFAULT
                             -> case x of x0 { DEFAULT ->
                                ProjectJson.$sfromList1
                                  @ a
                                  (Data.Map.Base.Bin
                                     @ XMapTypes.XMapKey
                                     @ a
                                     1#
                                     (Data.Text.Internal.Text ww1 ww2 ww3)
                                       `cast`
                                     (Sym (XMapTypes.N:XMapKey[0]))
                                     x0
                                     (Data.Map.Base.Tip @ XMapTypes.XMapKey @ a)
                                     (Data.Map.Base.Tip @ XMapTypes.XMapKey @ a))
                                  wild2 }
                             GHC.Types.LT
                             -> case x of x0 { DEFAULT ->
                                ProjectJson.$wpoly_go4
                                  @ a
                                  1#
                                  (Data.Map.Base.Bin
                                     @ XMapTypes.XMapKey
                                     @ a
                                     1#
                                     (Data.Text.Internal.Text ww1 ww2 ww3)
                                       `cast`
                                     (Sym (XMapTypes.N:XMapKey[0]))
                                     x0
                                     (Data.Map.Base.Tip @ XMapTypes.XMapKey @ a)
                                     (Data.Map.Base.Tip @ XMapTypes.XMapKey @ a))
                                  wild2 } } } } } } } }) -}
5e430c68cf0969392e0ce6e91e8aac03
  $sfromList1 ::
    Data.Map.Base.Map XMapTypes.XMapKey a1
    -> [(XMapTypes.XMapKey, a1)]
    -> Data.Map.Base.Map XMapTypes.XMapKey a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
123a0049f97eff0899a456bdf3a3ec4b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ProjectJson.$trModule2
                   ProjectJson.$trModule1) -}
9dbc5219cbdb77d6f3e3d64cf0e89a85
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ProjectJson"#) -}
066fff0eb99523f02f77576bb1e968c0
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
06ae915328a30a7845ff9150a05ffe39
  $w$ctoJSON ::
    Project.AllProjects -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Project.AllProjects) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONAllProjects3,
                            case GHC.Magic.runRW#
                                   @ 'GHC.Types.PtrRepLifted
                                   @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                   (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                    case GHC.Prim.newArray#
                                           @ Data.Aeson.Types.Internal.Value
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           0#
                                           (Data.Vector.Mutable.uninitialised
                                              @ Data.Aeson.Types.Internal.Value)
                                           s1
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds9 { (#,#) ipv ipv1 ->
                                    case ProjectJson.$fToJSONAllProjects2
                                           GHC.Types.SPEC
                                           ((Data.Vector.Mutable.MVector
                                               @ (Control.Monad.Primitive.PrimState
                                                    (GHC.ST.ST GHC.Prim.RealWorld))
                                               @ Data.Aeson.Types.Internal.Value
                                               0#
                                               0#
                                               ipv1)
                                              `cast`
                                            (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                             (GHC.ST.ST
                                                                                                GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                            ProjectJson.$fToJSONAllProjects1)
                                           (GHC.Base.map
                                              @ Project.ProjectName
                                              @ Data.Aeson.Types.Internal.Value
                                              Data.Aeson.Types.Internal.$WString
                                                `cast`
                                              (Sym (Project.N:ProjectName[0])
                                               ->_R <Data.Aeson.Types.Internal.Value>_R)
                                              w `cast` (Project.N:AllProjects[0]))
                                           ipv
                                             `cast`
                                           (GHC.Prim.State#
                                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                   <GHC.Prim.RealWorld>_N))_R of ds10 { (#,#) ipv6 ipv7 ->
                                    case ipv7 of wild5 { (,) v' n ->
                                    case v'
                                           `cast`
                                         (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                    (GHC.ST.ST
                                                                                       GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                    case n of dt5 { GHC.Types.I# dt6 ->
                                    case GHC.Prim.unsafeFreezeArray#
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           @ Data.Aeson.Types.Internal.Value
                                           dt2
                                           ipv6
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                    (# ipv2
                                         `cast`
                                       (GHC.Prim.State#
                                          (Control.Monad.Primitive.D:R:PrimStateST[0]
                                               <GHC.Prim.RealWorld>_N))_R,
                                       Data.Vector.Vector
                                         @ Data.Aeson.Types.Internal.Value
                                         dt
                                         dt6
                                         ipv3 #) } } } } } }) of ds9 { (#,#) ipv1 ipv2 ->
                            case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                            Data.Aeson.Types.Internal.Array dt1 } })
                           (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
0cf7a2128e742ecef56b3d559526de7d
  $w$ctoJSON1 ::
    XMapTypes.XMapName
    -> Formula.XFormula
    -> XFunction.OperationMode
    -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: XMapTypes.XMapName)
                   (ww1 :: Formula.XFormula)
                   (ww2 :: XFunction.OperationMode) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fToJSONCalculation4,
                            ProjectJson.$fToJSONCalculation_$ctoJSON3 ww)
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fToJSONCalculation2,
                               ProjectJson.$fToJSONCalculation_$ctoJSON2 ww1)
                              (GHC.Types.:
                                 @ Data.Aeson.Types.Internal.Pair
                                 (ProjectJson.$fToJSONCalculation1,
                                  ProjectJson.$fToJSONCalculation_$ctoJSON1 ww2)
                                 (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair))))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
5a0cf1bb43ada28d011de29c98bfacdf
  $w$ctoJSON10 ::
    View.ViewItem -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: View.ViewItem) ->
                 case w of wild {
                   View.MapItem mapName
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONView5
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONView4,
                                    ProjectJson.$fToJSONCalculation_$ctoJSON3 mapName)
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) }
                   View.LabelItem label
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONView2
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONView1,
                                    Data.Aeson.Types.Internal.$WString
                                      label `cast` (View.N:ViewLabel[0]))
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) } }) -}
139ca123f1c4ff0fa37eee33c76be41d
  $w$ctoJSON11 ::
    XMapTypes.XMap -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f0172fd61d639f13ce622a9cade9987c
  $w$ctoJSON2 ::
    XFunction.OperationMode -> (# Data.Text.Internal.Text #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: XFunction.OperationMode) ->
                 case case w of wild {
                        XFunction.Union -> XFunction.$fReadOperationMode11
                        XFunction.Intersection
                        -> XFunction.$fReadOperationMode8 } of dt { DEFAULT ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ Data.Text.Internal.Text
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds9 { (#,#) ipv ipv1 ->
                         TextEnums.$wouter ipv1 4# dt 0# ipv }) of ds9 { (#,#) ipv ipv1 ->
                 case ipv1 of dt1 { Data.Text.Internal.Text ipv2 ipv3 ipv4 ->
                 (# dt1 #) } } }) -}
a94ace64972f1b60d1b67f72b136d681
  $w$ctoJSON3 ::
    Formula.XFormula -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
be8a6a2919c2fdbb8f6aa5ea28df4efd
  $w$ctoJSON4 ::
    OperationTypes.OperationName -> (# Data.Text.Internal.Text #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: OperationTypes.OperationName) ->
                 case case w of wild {
                        OperationTypes.Add -> OperationTypes.$fReadOperationName11
                        OperationTypes.Subtract
                        -> OperationTypes.$fReadOperationName8 } of dt { DEFAULT ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ Data.Text.Internal.Text
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds9 { (#,#) ipv ipv1 ->
                         TextEnums.$wouter ipv1 4# dt 0# ipv }) of ds9 { (#,#) ipv ipv1 ->
                 case ipv1 of dt1 { Data.Text.Internal.Text ipv2 ipv3 ipv4 ->
                 (# dt1 #) } } }) -}
4c87f334576cd59eebacc1d7159b6a82
  $w$ctoJSON5 ::
    Project.ProjectName
    -> [Project.Calculation]
    -> [View.ViewName]
    -> [Project.Source]
    -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,1*U>, Inline: [0] -}
ec2b9995b4276cf2fccf51dd770c5d6d
  $w$ctoJSON6 ::
    Project.SourceType
    -> [XMapTypes.XMapName] -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 2, Strictness: <L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Project.SourceType)
                   (ww1 :: [XMapTypes.XMapName]) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONSource6,
                            ProjectJson.$fToJSONSource_$ctoJSON1 ww)
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fFromJSONSource2,
                               case GHC.Magic.runRW#
                                      @ 'GHC.Types.PtrRepLifted
                                      @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                      (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.newArray#
                                              @ Data.Aeson.Types.Internal.Value
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              0#
                                              (Data.Vector.Mutable.uninitialised
                                                 @ Data.Aeson.Types.Internal.Value)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds9 { (#,#) ipv ipv1 ->
                                       case ProjectJson.$fToJSONSource1
                                              GHC.Types.SPEC
                                              ((Data.Vector.Mutable.MVector
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  @ Data.Aeson.Types.Internal.Value
                                                  0#
                                                  0#
                                                  ipv1)
                                                 `cast`
                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                (GHC.ST.ST
                                                                                                   GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                               ProjectJson.$fToJSONAllProjects1)
                                              (GHC.Base.map
                                                 @ XMapTypes.XMapName
                                                 @ Data.Aeson.Types.Internal.Value
                                                 ProjectJson.$fToJSONCalculation_$ctoJSON3
                                                 ww1)
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of ds10 { (#,#) ipv6 ipv7 ->
                                       case ipv7 of wild5 { (,) v' n ->
                                       case v'
                                              `cast`
                                            (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       (GHC.ST.ST
                                                                                          GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                       case n of dt5 { GHC.Types.I# dt6 ->
                                       case GHC.Prim.unsafeFreezeArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              @ Data.Aeson.Types.Internal.Value
                                              dt2
                                              ipv6
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          Data.Vector.Vector
                                            @ Data.Aeson.Types.Internal.Value
                                            dt
                                            dt6
                                            ipv3 #) } } } } } }) of ds9 { (#,#) ipv1 ipv2 ->
                               case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                               Data.Aeson.Types.Internal.Array dt1 } })
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
e7e1f94d13ad4196f682908717851517
  $w$ctoJSON7 ::
    Data.Text.Internal.Text
    -> [Project.ProjectName] -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Data.Text.Internal.Text)
                   (ww1 :: [Project.ProjectName]) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONUser5,
                            Data.Aeson.Types.Internal.$WString ww)
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fFromJSONUser2,
                               case GHC.Magic.runRW#
                                      @ 'GHC.Types.PtrRepLifted
                                      @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                      (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.newArray#
                                              @ Data.Aeson.Types.Internal.Value
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              0#
                                              (Data.Vector.Mutable.uninitialised
                                                 @ Data.Aeson.Types.Internal.Value)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds9 { (#,#) ipv ipv1 ->
                                       case ProjectJson.$fToJSONUser1
                                              GHC.Types.SPEC
                                              ((Data.Vector.Mutable.MVector
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  @ Data.Aeson.Types.Internal.Value
                                                  0#
                                                  0#
                                                  ipv1)
                                                 `cast`
                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                (GHC.ST.ST
                                                                                                   GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                               ProjectJson.$fToJSONAllProjects1)
                                              (GHC.Base.map
                                                 @ Project.ProjectName
                                                 @ Data.Aeson.Types.Internal.Value
                                                 Data.Aeson.Types.Internal.$WString
                                                   `cast`
                                                 (Sym (Project.N:ProjectName[0])
                                                  ->_R <Data.Aeson.Types.Internal.Value>_R)
                                                 ww1)
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of ds10 { (#,#) ipv6 ipv7 ->
                                       case ipv7 of wild5 { (,) v' n ->
                                       case v'
                                              `cast`
                                            (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       (GHC.ST.ST
                                                                                          GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                       case n of dt5 { GHC.Types.I# dt6 ->
                                       case GHC.Prim.unsafeFreezeArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              @ Data.Aeson.Types.Internal.Value
                                              dt2
                                              ipv6
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          Data.Vector.Vector
                                            @ Data.Aeson.Types.Internal.Value
                                            dt
                                            dt6
                                            ipv3 #) } } } } } }) of ds9 { (#,#) ipv1 ipv2 ->
                               case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                               Data.Aeson.Types.Internal.Array dt1 } })
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
f0c4058fdb16bbbed62a9123185fd41d
  $w$ctoJSON8 ::
    View.ViewName
    -> [View.ViewRow] -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: View.ViewName) (ww1 :: [View.ViewRow]) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONView9,
                            Data.Aeson.Types.Internal.$WString ww `cast` (View.N:ViewName[0]))
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fFromJSONView2,
                               case GHC.Magic.runRW#
                                      @ 'GHC.Types.PtrRepLifted
                                      @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                      (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.newArray#
                                              @ Data.Aeson.Types.Internal.Value
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              0#
                                              (Data.Vector.Mutable.uninitialised
                                                 @ Data.Aeson.Types.Internal.Value)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds9 { (#,#) ipv ipv1 ->
                                       case ProjectJson.$fToJSONView8
                                              GHC.Types.SPEC
                                              ((Data.Vector.Mutable.MVector
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  @ Data.Aeson.Types.Internal.Value
                                                  0#
                                                  0#
                                                  ipv1)
                                                 `cast`
                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                (GHC.ST.ST
                                                                                                   GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                               ProjectJson.$fToJSONAllProjects1)
                                              (GHC.Base.map
                                                 @ View.ViewRow
                                                 @ Data.Aeson.Types.Internal.Value
                                                 ProjectJson.$fToJSONView_$ctoJSON1
                                                 ww1)
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of ds10 { (#,#) ipv6 ipv7 ->
                                       case ipv7 of wild5 { (,) v' n ->
                                       case v'
                                              `cast`
                                            (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       (GHC.ST.ST
                                                                                          GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                       case n of dt5 { GHC.Types.I# dt6 ->
                                       case GHC.Prim.unsafeFreezeArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              @ Data.Aeson.Types.Internal.Value
                                              dt2
                                              ipv6
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          Data.Vector.Vector
                                            @ Data.Aeson.Types.Internal.Value
                                            dt
                                            dt6
                                            ipv3 #) } } } } } }) of ds9 { (#,#) ipv1 ipv2 ->
                               case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                               Data.Aeson.Types.Internal.Array dt1 } })
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
17585ec607f87f87c99c648910777c43
  $w$ctoJSON9 ::
    View.ViewRow -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (w :: View.ViewRow) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONViewRow1,
                            case GHC.Magic.runRW#
                                   @ 'GHC.Types.PtrRepLifted
                                   @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                   (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                    case GHC.Prim.newArray#
                                           @ Data.Aeson.Types.Internal.Value
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           0#
                                           (Data.Vector.Mutable.uninitialised
                                              @ Data.Aeson.Types.Internal.Value)
                                           s1
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds9 { (#,#) ipv ipv1 ->
                                    case ProjectJson.$fToJSONView7
                                           GHC.Types.SPEC
                                           ((Data.Vector.Mutable.MVector
                                               @ (Control.Monad.Primitive.PrimState
                                                    (GHC.ST.ST GHC.Prim.RealWorld))
                                               @ Data.Aeson.Types.Internal.Value
                                               0#
                                               0#
                                               ipv1)
                                              `cast`
                                            (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                             (GHC.ST.ST
                                                                                                GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                            ProjectJson.$fToJSONAllProjects1)
                                           (GHC.Base.map
                                              @ View.ViewItem
                                              @ Data.Aeson.Types.Internal.Value
                                              ProjectJson.$fToJSONView_$ctoJSON2
                                              w `cast` (View.N:ViewRow[0]))
                                           ipv
                                             `cast`
                                           (GHC.Prim.State#
                                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                   <GHC.Prim.RealWorld>_N))_R of ds10 { (#,#) ipv6 ipv7 ->
                                    case ipv7 of wild5 { (,) v' n ->
                                    case v'
                                           `cast`
                                         (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                    (GHC.ST.ST
                                                                                       GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                    case n of dt5 { GHC.Types.I# dt6 ->
                                    case GHC.Prim.unsafeFreezeArray#
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           @ Data.Aeson.Types.Internal.Value
                                           dt2
                                           ipv6
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                    (# ipv2
                                         `cast`
                                       (GHC.Prim.State#
                                          (Control.Monad.Primitive.D:R:PrimStateST[0]
                                               <GHC.Prim.RealWorld>_N))_R,
                                       Data.Vector.Vector
                                         @ Data.Aeson.Types.Internal.Value
                                         dt
                                         dt6
                                         ipv3 #) } } } } } }) of ds9 { (#,#) ipv1 ipv2 ->
                            case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                            Data.Aeson.Types.Internal.Array dt1 } })
                           (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
6d2de46612b34190bd8cd527316582aa
  $w$sgo4 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a1
    -> Data.Map.Base.Map XMapTypes.XMapKey a1
    -> Data.Map.Base.Map XMapTypes.XMapKey a1
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,1*U><S,1*U>,
     Inline: [0] -}
44097c4f365bb87e6cd3003ae65671d0
  $w$slookup ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap Data.Text.Internal.Text v
    -> GHC.Base.Maybe v
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><S,U><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ v
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (w :: Data.HashMap.Base.HashMap Data.Text.Internal.Text v) ->
                 case {__pkg_ccall hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol hashable_fnv_hash_offset GHC.Prim.ByteArray#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.State#
                                                                                                                          GHC.Prim.RealWorld
                                                                                                                     -> (# GHC.Prim.State#
                                                                                                                             GHC.Prim.RealWorld,
                                                                                                                           GHC.Prim.Int# #)}
                        ww
                        (GHC.Prim.uncheckedIShiftL# ww1 1#)
                        (GHC.Prim.uncheckedIShiftL# ww2 1#)
                        -2578643520546668380#
                        GHC.Prim.realWorld# of wild1 { (#,#) ds9 ds10 ->
                 ProjectJson.$wpoly_go2
                   @ v
                   (GHC.Prim.int2Word# ds10)
                   ww
                   ww1
                   ww2
                   0#
                   w }) -}
4e3685106bc17bd3ec8acd3d84fbc42f
  $wpoly_go1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array#
         (Data.HashMap.Base.Leaf Data.Text.Internal.Text v)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe v
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><S,U><S,U><S,U>, Inline: [0] -}
13bd039bae738a516852d8e7b25ae22f
  $wpoly_go2 ::
    GHC.Prim.Word#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap Data.Text.Internal.Text v
    -> GHC.Base.Maybe v
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><S,1*U>, Inline: [0] -}
1195e463170913e5a8ca3d0a951906cf
  $wpoly_go4 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map XMapTypes.XMapKey a
    -> [(XMapTypes.XMapKey, a)]
    -> Data.Map.Base.Map XMapTypes.XMapKey a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
instance Data.Aeson.Types.FromJSON.FromJSON [Project.AllProjects]
  = ProjectJson.$fFromJSONAllProjects
instance Data.Aeson.Types.FromJSON.FromJSON [ApplicationTypes.ApplicationName]
  = ProjectJson.$fFromJSONApplicationName
instance Data.Aeson.Types.FromJSON.FromJSON [Project.Calculation]
  = ProjectJson.$fFromJSONCalculation
instance Data.Aeson.Types.FromJSON.FromJSON [XFunction.OperationMode]
  = ProjectJson.$fFromJSONOperationMode
instance Data.Aeson.Types.FromJSON.FromJSON [OperationTypes.OperationName]
  = ProjectJson.$fFromJSONOperationName
instance Data.Aeson.Types.FromJSON.FromJSON [Project.Project]
  = ProjectJson.$fFromJSONProject
instance Data.Aeson.Types.FromJSON.FromJSON [Project.ProjectName]
  = ProjectJson.$fFromJSONProjectName
instance Data.Aeson.Types.FromJSON.FromJSON [Project.Source]
  = ProjectJson.$fFromJSONSource
instance Data.Aeson.Types.FromJSON.FromJSON [Project.SourceType]
  = ProjectJson.$fFromJSONSourceType
instance Data.Aeson.Types.FromJSON.FromJSON [Project.User]
  = ProjectJson.$fFromJSONUser
instance Data.Aeson.Types.FromJSON.FromJSON [View.View]
  = ProjectJson.$fFromJSONView
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewItem]
  = ProjectJson.$fFromJSONViewItem
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewLabel]
  = ProjectJson.$fFromJSONViewLabel
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewName]
  = ProjectJson.$fFromJSONViewName
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewRow]
  = ProjectJson.$fFromJSONViewRow
instance Data.Aeson.Types.FromJSON.FromJSON [Formula.XFormula]
  = ProjectJson.$fFromJSONXFormula
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XMap]
  = ProjectJson.$fFromJSONXMap
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XMapKey]
  = ProjectJson.$fFromJSONXMapKey
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XMapName]
  = ProjectJson.$fFromJSONXMapName
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XNamedMap]
  = ProjectJson.$fFromJSONXNamedMap
instance Data.Aeson.Types.ToJSON.ToJSON [Project.AllProjects]
  = ProjectJson.$fToJSONAllProjects
instance Data.Aeson.Types.ToJSON.ToJSON [ApplicationTypes.ApplicationName]
  = ProjectJson.$fToJSONApplicationName
instance Data.Aeson.Types.ToJSON.ToJSON [Project.Calculation]
  = ProjectJson.$fToJSONCalculation
instance Data.Aeson.Types.ToJSON.ToJSON [XFunction.OperationMode]
  = ProjectJson.$fToJSONOperationMode
instance Data.Aeson.Types.ToJSON.ToJSON [OperationTypes.OperationName]
  = ProjectJson.$fToJSONOperationName
instance Data.Aeson.Types.ToJSON.ToJSON [Project.Project]
  = ProjectJson.$fToJSONProject
instance Data.Aeson.Types.ToJSON.ToJSON [Project.ProjectName]
  = ProjectJson.$fToJSONProjectName
instance Data.Aeson.Types.ToJSON.ToJSON [Project.Source]
  = ProjectJson.$fToJSONSource
instance Data.Aeson.Types.ToJSON.ToJSON [Project.SourceType]
  = ProjectJson.$fToJSONSourceType
instance Data.Aeson.Types.ToJSON.ToJSON [Project.User]
  = ProjectJson.$fToJSONUser
instance Data.Aeson.Types.ToJSON.ToJSON [View.View]
  = ProjectJson.$fToJSONView
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewItem]
  = ProjectJson.$fToJSONViewItem
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewLabel]
  = ProjectJson.$fToJSONViewLabel
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewName]
  = ProjectJson.$fToJSONViewName
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewRow]
  = ProjectJson.$fToJSONViewRow
instance Data.Aeson.Types.ToJSON.ToJSON [Formula.XFormula]
  = ProjectJson.$fToJSONXFormula
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XMap]
  = ProjectJson.$fToJSONXMap
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XMapKey]
  = ProjectJson.$fToJSONXMapKey
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XMapName]
  = ProjectJson.$fToJSONXMapName
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XNamedMap]
  = ProjectJson.$fToJSONXNamedMap
"SPEC/ProjectJson fromList @ XMapKey _" [ALWAYS] forall @ a
                                                        ($dOrd :: GHC.Classes.Ord XMapTypes.XMapKey)
  Data.Map.Strict.fromList @ XMapTypes.XMapKey @ a $dOrd
  = ProjectJson.$sfromList @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

