
==================== FINAL INTERFACE ====================
2017-11-08 19:12:33.577870077 UTC

interface main@main:ProjectJson [orphan module] 8002
  interface hash: 1956c4f000ca04d005bb5af5b3c6f698
  ABI hash: acf18b712df8a0f901e55f49f516e8ae
  export-list hash: 7c021a43116ce3cd9ba9642848771ff1
  orphan hash: 9b7406d6e5175cfe90ea4a75f3365919
  flag hash: 088bb1e6d18d42d290c9ca2a5ad09f41
  sig of: Nothing
  used TH splices: False
  where
exports:
module dependencies: ApplicationTypes Calculation Errors Formula
                     OperationTypes Project TextEnums View XFunction XMapJson XMapTypes
                     XValues
package dependencies: aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK
                      array-0.5.1.1@array-0.5.1.1
                      attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna
                      base-4.9.1.0
                      base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      dlist-0.8.0.3@dlist-0.8.0.3-BHFBNaw8k6n9WiaUNzoXpk
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1
                      integer-logarithms-1.0.2@integer-logarithms-1.0.2-92lMiWV9mmYAwfMEYgfQ0D
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      scientific-0.3.5.1@scientific-0.3.5.1-JHsAAp34Yyd8e5v3sK3O5Q
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      time-1.6.0.1@time-1.6.0.1
                      time-locale-compat-0.1.1.3@time-locale-compat-0.1.1.3-KZ1jqNx8uhlHjmuPPj6V1Y
                      transformers-0.5.2.0@transformers-0.5.2.0
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
                      uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
orphans: attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.ByteString.Char8
         attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.Text.Internal
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         main@main:XMapJson
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.Internal.Types
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         dlist-0.8.0.3@dlist-0.8.0.3-BHFBNaw8k6n9WiaUNzoXpk:Data.DList
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Data.Primitive.Array
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
                         uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ:Data.UUID.Types.Internal
                         uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Storable
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed.Base
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson 2e25d14a91e9ff13092f56c3ec0cd425
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.FromJSON 4689ca8eaf34be826a16963134272afc
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.Internal c533249add6a1886866510b882a9b441
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.ToJSON 032e11a60f09165b3d041ef0b452cae8
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ApplicationTypes 143822343c6f7fa9393e7f65b91b4440
  exports: c8a509b10500b8e668c0d339e53814fa
  ApplicationName 7d51253c4c8955e3629ff4b12eb2b14e
import  -/  Calculation 2ffc34f2be3e84d0a1939c6ca84c8da7
  exports: 5c332b8fd8fef070186c5200f58f2914
  Calculation 03698bd51c60bb7b5080d27c1b8658b8
  Calculation d417b5b8b099f384a090c1e4806d4f1d
  CalculationFormulaText 190506ef3f5899e15e830e35f1934183
  CalculationFormulaText fd38426093a918ee049ab7c4fb1fb4f2
  CalculationName 33a8590d875a915188f9bbf7f53d4cad
  CalculationName 7681f69b2581ed31254c1a456f024695
  CalculationSource 47b955d852fafbfdbe394604d83bca66
  CalculationSource 4d7c220a24400e7a90de59dfe2149dc6
  Functions e32b57de328035550337609ef7cf4c68
  Functions 76913b8c92b440c4f1a034f58c20c5b1
import  -/  Formula 09444ea12c0441bd37404b175a926171
  exports: d6ceee93beb5ac820afa97f35b5fa611
  XFApplication eb8c3b77bcb22eb578439fc9251971f9
  XFMap 7dbf5543fca58ffc0e04840d8a0f5725
  XFOperation 81ff2bf2a641ffbde51c62d91ea8aaf4
  XFormula fb924f832976f886aefc5a3d03a23b47
import  -/  OperationTypes 6975e529b4a89f8050baa8dcbf38831a
  exports: 1a323fe5f5d42124be5996496a88719d
  OperationName a5a60b294983bcb41d5e4136aac111fd
import  -/  Project e9aaa611811a510eec90fd878cb1c85f
  exports: a1b12012f0f388e6620b2d764b9da9c5
  AllProjects 35135f9c77587ad25ef5fedd60d3f572
  AllProjects 5112a5d43849857c03604773be3e85a2
  FileSource 257fe49100eecd56f874d64683d51d99
  HttpSource e5d1967389d626f96f6de48699ac05cb
  OdbcSource 29e23861ef351a8dc7680533531077f7
  Project 0c411bbbdb86d102b55e0b64ae3c6841
  Project c7f6766f61d0b63c7ab6927b16e914f3
  ProjectName 88a5198f7b44b8586232adf22e56ae2a
  ProjectName dc3277e72c5d1fd0c29f02dc48899838
  Source da908b3d55c3b3e54552f97841f9dea4
  Source c41016d233cbedf3a4568ce830d45f45
  SourceType 28d148184fb0f06dc30c86418e1b0d4f
  User 04b9a32a67174b83c88cb855401cc138
  User 72afc65efc42b8e8a12e5e1696ba9e3b
import  -/  TextEnums 5bbcd69e17f621fccc64fe2d0e459af9
  exports: 6670f372a6b818595c7e6b6021015eca
  readT c50da94ac02a016fbe20df1e95b8c133
  showT 9da9061e371157579d8ad59cb1150038
import  -/  View 02361d7faa292e39c3bd07eb3d6b6b8e
  exports: 566a2406a41a78f1d65d3176e307799b
  LabelItem 3434f01a13626dc85c51091e03fdb138
  MapItem 708e458136cd9677a34a32de608f31f2
  View 9743bd334b51c92047571846fec7be71
  View 3a2375be1f5189e91eb0fabfa84fd0be
  ViewItem eb24c06f18238ff1494950db988ac0e9
  ViewLabel f2cda51f0694b9bffef52227952836e5
  ViewLabel 24961fd99fdaa15e1aebe70b7fc2c02b
  ViewName 4c6aad1e74bc6f916c25f7eddf2c9eb8
  ViewName 105e058b0f915624ee10874cf1c9d091
  ViewRow 184ac2a10a0416d6b9313091dbfe9519
  ViewRow a3fc67c22f4fd6049fe9dc14f457cef0
import  -/  XFunction daf3a8fe929e99b13bb1482148441fb5
  exports: e4744bd862d5d39381a3b81764a14b8c
  OperationMode ba1024ee7488d74e75d2aa7e9c371660
import  -/  XMapJson c20984cd2df0cdd5c0b86c8fb49b2e16
  exports: 4ac2a0aa4bf208de6d454547f1cdad95
import  -/  XMapTypes 83c3b05a6c33968c2e0bd82cfc322a5e
  exports: 63a1ffc24fb40991afaa24415fd501be
import  -/  text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text 28074c70d3351fb3368d27c0a438ae07
import  -/  unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base 42bdf194c392fb9c910c94a2b5aa1ff1
import  -/  unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Lazy fc12dd068603a4b3dd39186b8a9fe7b5
150181a4a30fb0ee86d8998387c62a5e
  $fFromJSONAllProjects ::
    Data.Aeson.Types.FromJSON.FromJSON Project.AllProjects
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.AllProjects
                  ProjectJson.$fFromJSONAllProjects_$cparseJSON
                  ProjectJson.$fFromJSONAllProjects_$cparseJSONList -}
a62d2b90cf9ad41d5afc1bd498aa6541
  $fFromJSONAllProjects1 ::
    [Data.Aeson.Types.Internal.Parser Project.AllProjects]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.AllProjects] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
57837c9d135645ab5374d390924205f3
  $fFromJSONAllProjects2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "[a]"#) -}
59559cb78d8361d3ca645f28ebf37610
  $fFromJSONAllProjects3 ::
    [Data.Aeson.Types.Internal.Parser Project.ProjectName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.ProjectName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
ae056ad8187b2c9fb394a4d76405fb88
  $fFromJSONAllProjects_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.AllProjects
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (v :: Data.Aeson.Types.Internal.Value) ->
                 let {
                   m :: Data.Aeson.Types.Internal.Parser [Project.ProjectName]
                   = ProjectJson.$fFromJSONAllProjects_$cparseJSONList1 v
                 } in
                 (\ @ (f21 :: * -> *)
                    @ r
                    (path :: Data.Aeson.Types.Internal.JSONPath)
                    (kf :: Data.Aeson.Types.Internal.Failure f21 r)
                    (ks :: Data.Aeson.Types.Internal.Success
                             Project.AllProjects f21 r) ->
                  m `cast`
                  (Data.Aeson.Types.Internal.N:Parser[0] <[Project.ProjectName]>_R)
                    @ f21
                    @ r
                    path
                    kf
                    (\ (a1 :: [Project.ProjectName]) ->
                     ks a1 `cast` (Sym (Project.N:AllProjects[0]))))
                   `cast`
                 (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                           <Project.AllProjects>_R))) -}
f92abdb8e95e987cc7b99b58534c49bd
  $fFromJSONAllProjects_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.AllProjects]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.AllProjects]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONAllProjects1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONAllProjects_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.AllProjects]>_R)) } }) -}
246e45ed223e2b3516f9da3be7f932c4
  $fFromJSONAllProjects_$cparseJSONList1 ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.ProjectName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.ProjectName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONAllProjects3
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONAllProjects_go1 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.ProjectName]>_R)) } }) -}
1a23e4be23c455c71d62412e8fb48110
  $fFromJSONAllProjects_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.AllProjects]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
0b9337ba805758b679383692d6032ae8
  $fFromJSONAllProjects_go1 ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.ProjectName]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
0819e1ff4a28d99dff99b493b50fd911
  $fFromJSONApplicationName ::
    Data.Aeson.Types.FromJSON.FromJSON ApplicationTypes.ApplicationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ApplicationTypes.ApplicationName
                  ProjectJson.$fFromJSONApplicationName_$cparseJSON
                  ProjectJson.$fFromJSONApplicationName_$cparseJSONList -}
68dc5e2e72f35df3c0f17ddd07c83161
  $fFromJSONApplicationName1 ::
    [Data.Aeson.Types.Internal.Parser ApplicationTypes.ApplicationName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            [ApplicationTypes.ApplicationName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
b86d68739ba4dfc64441451352378f65
  $fFromJSONApplicationName2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            ApplicationTypes.ApplicationName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              ApplicationTypes.ApplicationName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> eta1
                        (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement eta)
                        ProjectJson.$fFromJSONApplicationName3
                   Data.Aeson.Types.Internal.String v
                   -> eta2
                        (TextEnums.readT
                           @ ApplicationTypes.ApplicationName
                           ApplicationTypes.$fReadApplicationName
                           v) }) -}
36cf9278a554003201f6820a79c04354
  $fFromJSONApplicationName3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "mempty"#) -}
70efc68a9a96e7e9374c2bce583131c0
  $fFromJSONApplicationName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser
         ApplicationTypes.ApplicationName
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONApplicationName2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <ApplicationTypes.ApplicationName>_R)) -}
868917225fc4506522e06787b7bfed22
  $fFromJSONApplicationName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser
         [ApplicationTypes.ApplicationName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [ApplicationTypes.ApplicationName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONApplicationName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONApplicationName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[ApplicationTypes.ApplicationName]>_R)) } }) -}
6e3a5e9be99efdead6eb2a6b40531610
  $fFromJSONApplicationName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser
          ApplicationTypes.ApplicationName]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
4690ad6a4991a8f611201ad0a112a800
  $fFromJSONCalculation ::
    Data.Aeson.Types.FromJSON.FromJSON Calculation.Calculation
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.Calculation
                  ProjectJson.$fFromJSONCalculation_$cparseJSON
                  ProjectJson.$fFromJSONCalculation_$cparseJSONList -}
91ac05b4c5fc6b55f34ebf5be109185d
  $fFromJSONCalculation1 ::
    [Data.Aeson.Types.Internal.Parser Calculation.Calculation]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Calculation.Calculation] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
c9f47642012d76266a7898c7cf71f463
  $fFromJSONCalculationFormulaText ::
    Data.Aeson.Types.FromJSON.FromJSON
      Calculation.CalculationFormulaText
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.CalculationFormulaText
                  ProjectJson.$fFromJSONCalculationFormulaText_$cparseJSON
                  ProjectJson.$fFromJSONCalculationFormulaText_$cparseJSONList -}
9b19ca8c811bc42573e90c0b9b17fa79
  $fFromJSONCalculationFormulaText1 ::
    [Data.Aeson.Types.Internal.Parser
       Calculation.CalculationFormulaText]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            [Calculation.CalculationFormulaText] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
3cbb17cf23be5529b8e3c0722837caa9
  $fFromJSONCalculationFormulaText2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            Calculation.CalculationFormulaText f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              Calculation.CalculationFormulaText f r) ->
                 case ds of wild {
                   DEFAULT
                   -> case ProjectJson.$fFromJSONCalculationFormulaText3
                      ret_ty (f r)
                      of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2
                        v `cast` (Sym (Calculation.N:CalculationFormulaText[0])) }) -}
bb48fe47e45f70c2a3c4ab1ad2ed2750
  $fFromJSONCalculationFormulaText3 ::
    Data.Aeson.Types.Internal.Parser Calculation.CalculationFormulaText
  {- Strictness: x -}
d398d01b9f248dde46b97851b4d0a75f
  $fFromJSONCalculationFormulaText_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser
         Calculation.CalculationFormulaText
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONCalculationFormulaText2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <Calculation.CalculationFormulaText>_R)) -}
cf27aaed90ad1624f526d715bc9a6a8d
  $fFromJSONCalculationFormulaText_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser
         [Calculation.CalculationFormulaText]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Calculation.CalculationFormulaText]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONCalculationFormulaText1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONCalculationFormulaText_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Calculation.CalculationFormulaText]>_R)) } }) -}
162410e9360a9fa4e7746143fa6f2da2
  $fFromJSONCalculationFormulaText_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser
          Calculation.CalculationFormulaText]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
de22ef68fb6d29d7460c00fcc52bd276
  $fFromJSONCalculationName ::
    Data.Aeson.Types.FromJSON.FromJSON Calculation.CalculationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.CalculationName
                  ProjectJson.$fFromJSONCalculationName_$cparseJSON
                  ProjectJson.$fFromJSONCalculationName_$cparseJSONList -}
36b95be6b52e058732d6eeef217ac422
  $fFromJSONCalculationName1 ::
    [Data.Aeson.Types.Internal.Parser Calculation.CalculationName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            [Calculation.CalculationName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
90e54a86348c5d27f9062bf5df501935
  $fFromJSONCalculationName2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            Calculation.CalculationName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              Calculation.CalculationName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> case ProjectJson.$fFromJSONCalculationName3 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (Calculation.N:CalculationName[0])) }) -}
7f1da7c2cb1447815f26eeb1e00f19b3
  $fFromJSONCalculationName3 ::
    Data.Aeson.Types.Internal.Parser Calculation.CalculationName
  {- Strictness: x -}
eb47f576d9733a762c6e24f2c791d2e9
  $fFromJSONCalculationName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Calculation.CalculationName
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONCalculationName2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <Calculation.CalculationName>_R)) -}
2f8afbd41c991760a95ae6ac6c9f155c
  $fFromJSONCalculationName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Calculation.CalculationName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Calculation.CalculationName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONCalculationName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONCalculationName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Calculation.CalculationName]>_R)) } }) -}
8ba782a096cbbd77b7dd9e5142a97eab
  $fFromJSONCalculationName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Calculation.CalculationName]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
8a7525d3a1ccd367e8c3a928af8aa123
  $fFromJSONCalculationSource ::
    Data.Aeson.Types.FromJSON.FromJSON Calculation.CalculationSource
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.CalculationSource
                  ProjectJson.$fFromJSONCalculationSource_$cparseJSON
                  ProjectJson.$fFromJSONCalculationSource_$cparseJSONList -}
2d7a1abb79b4756f9607bf5d0b9f630d
  $fFromJSONCalculationSource1 ::
    [Data.Aeson.Types.Internal.Parser Calculation.CalculationSource]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            [Calculation.CalculationSource] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
8b98ed3973de0c68e6794ef523c87bf1
  $fFromJSONCalculationSource_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Calculation.CalculationSource
  {- Arity: 1, Strictness: <S,1*U> -}
1fffa3179f9f25f732ae6dd31fe23ef9
  $fFromJSONCalculationSource_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Calculation.CalculationSource]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Calculation.CalculationSource]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONCalculationSource1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONCalculationSource_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Calculation.CalculationSource]>_R)) } }) -}
f951dcccde34fd82a46949e7978b72fb
  $fFromJSONCalculationSource_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Calculation.CalculationSource]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
bee481f23daa55535a4effba68b92969
  $fFromJSONCalculation_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Calculation.Calculation
  {- Arity: 1, Strictness: <S,1*U> -}
ddc73c30ef886c2ac112dfc9f323d502
  $fFromJSONCalculation_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Calculation.Calculation]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Calculation.Calculation]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONCalculation1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONCalculation_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Calculation.Calculation]>_R)) } }) -}
d3f8fb292048b34f562af4724eb21a2a
  $fFromJSONCalculation_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Calculation.Calculation]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
6d27db84f60817daf373ed9ae30c6442
  $fFromJSONOperationMode ::
    Data.Aeson.Types.FromJSON.FromJSON XFunction.OperationMode
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XFunction.OperationMode
                  ProjectJson.$fFromJSONOperationMode_$cparseJSON
                  ProjectJson.$fFromJSONOperationMode_$cparseJSONList -}
aa8587da545df778656a56d3ea69e0f5
  $fFromJSONOperationMode1 ::
    [Data.Aeson.Types.Internal.Parser XFunction.OperationMode]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XFunction.OperationMode] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
366b0de2dcb0cb04f7c6cf669a7665b1
  $fFromJSONOperationMode2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success XFunction.OperationMode f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              XFunction.OperationMode f r) ->
                 case ds of wild {
                   DEFAULT
                   -> eta1
                        (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement eta)
                        ProjectJson.$fFromJSONApplicationName3
                   Data.Aeson.Types.Internal.String v
                   -> eta2
                        (TextEnums.readT
                           @ XFunction.OperationMode
                           XFunction.$fReadOperationMode
                           v) }) -}
96fb79f1652aa5c1e645b46874a0a87b
  $fFromJSONOperationMode_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XFunction.OperationMode
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONOperationMode2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <XFunction.OperationMode>_R)) -}
2166610c1af5966ea8c7c22c40e9b3ea
  $fFromJSONOperationMode_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XFunction.OperationMode]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XFunction.OperationMode]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONOperationMode1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONOperationMode_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XFunction.OperationMode]>_R)) } }) -}
e58dc810094496b2fefe14bac9738bbc
  $fFromJSONOperationMode_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XFunction.OperationMode]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
18cf105d2b9a66b93520bd797831e182
  $fFromJSONOperationName ::
    Data.Aeson.Types.FromJSON.FromJSON OperationTypes.OperationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ OperationTypes.OperationName
                  ProjectJson.$fFromJSONOperationName_$cparseJSON
                  ProjectJson.$fFromJSONOperationName_$cparseJSONList -}
27e200fb04164cb46106fa0e4e5c4268
  $fFromJSONOperationName1 ::
    [Data.Aeson.Types.Internal.Parser OperationTypes.OperationName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            [OperationTypes.OperationName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
a58650a4c9722a17ad8dd228de3f4f64
  $fFromJSONOperationName2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success
            OperationTypes.OperationName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              OperationTypes.OperationName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> eta1
                        (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement eta)
                        ProjectJson.$fFromJSONApplicationName3
                   Data.Aeson.Types.Internal.String v
                   -> eta2
                        (TextEnums.readT
                           @ OperationTypes.OperationName
                           OperationTypes.$fReadOperationName
                           v) }) -}
40f19b9722e8031c51f800497ded3089
  $fFromJSONOperationName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser OperationTypes.OperationName
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONOperationName2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <OperationTypes.OperationName>_R)) -}
6dc9911f187e5665a912e0937086ffeb
  $fFromJSONOperationName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [OperationTypes.OperationName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [OperationTypes.OperationName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONOperationName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONOperationName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[OperationTypes.OperationName]>_R)) } }) -}
fc7369cec0c81efcbfdc1b8655ec4342
  $fFromJSONOperationName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser OperationTypes.OperationName]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
8357aefca04b94e7b9cd2a30379227ca
  $fFromJSONProject ::
    Data.Aeson.Types.FromJSON.FromJSON Project.Project
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Project
                  ProjectJson.$fFromJSONProject_$cparseJSON
                  ProjectJson.$fFromJSONProject_$cparseJSONList -}
28e51b0950fa7ab944cf5533f88e3a99
  $fFromJSONProject1 ::
    [Data.Aeson.Types.Internal.Parser Project.Project]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.Project] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
789f4f7e9ee8dde5fd8846969181a824
  $fFromJSONProjectName ::
    Data.Aeson.Types.FromJSON.FromJSON Project.ProjectName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.ProjectName
                  ProjectJson.$fFromJSONProjectName_$cparseJSON
                  ProjectJson.$fFromJSONAllProjects_$cparseJSONList1 -}
d3557a297d6991998b79baaad5a5942c
  $fFromJSONProjectName1 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success Project.ProjectName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              Project.ProjectName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> eta1
                        (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement eta)
                        ProjectJson.$fFromJSONApplicationName3
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (Project.N:ProjectName[0])) }) -}
4c46ff74e532aad3b954b5196baa72c4
  $fFromJSONProjectName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.ProjectName
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONProjectName1
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <Project.ProjectName>_R)) -}
c28a2885e186806a893928bc13dee20a
  $fFromJSONProject_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.Project
  {- Arity: 1, Strictness: <S,1*U> -}
14f6bebc0d71f3758feb080943bc2c0d
  $fFromJSONProject_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.Project]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.Project]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONProject1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONProject_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.Project]>_R)) } }) -}
cf53664bca893bf7c34cbc3c3fa28bb3
  $fFromJSONProject_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.Project]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
8d96f16dc0e30aaee6aa19cdb4830b37
  $fFromJSONSource ::
    Data.Aeson.Types.FromJSON.FromJSON Project.Source
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Source
                  ProjectJson.$fFromJSONSource_$cparseJSON
                  ProjectJson.$fFromJSONSource_$cparseJSONList -}
f2a8abcef875f362c5a99abe2ca6897d
  $fFromJSONSource1 ::
    [Data.Aeson.Types.Internal.Parser Project.Source]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.Source] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
024ebc487032712c7d47f2146793819d
  $fFromJSONSource2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "sourceOfMaps"#) -}
1319998ef37e24c4167ed0e93ba4e366
  $fFromJSONSource3 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [XMapTypes.XMapName] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             [XMapTypes.XMapName] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONSource_msg3) -}
3d1843bf164252fe6316ec78a4fdecde
  $fFromJSONSource4 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONSource2 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONSource5 }) -}
c2c8d40084c67d3f5b499e3a1a98081b
  $fFromJSONSource5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " not present"#) -}
54bcd1db225430d15520e9403bfd5f9a
  $fFromJSONSource6 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "sourceType"#) -}
85e67ac7c68f334fb4fccc02b00592bd
  $fFromJSONSource7 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success Project.SourceType f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             Project.SourceType f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONSource_msg1) -}
51f65b2d9750115fd6adc3780c7de8ee
  $fFromJSONSource8 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONSource6 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONSource5 }) -}
2e6c3ae38594e2031a02fb8ebcef1e01
  $fFromJSONSourceType ::
    Data.Aeson.Types.FromJSON.FromJSON Project.SourceType
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.SourceType
                  ProjectJson.$fFromJSONSource_$cparseJSON1
                  ProjectJson.$fFromJSONSourceType_$cparseJSONList -}
3cbda5bd05e768e081fb91eb531ed70a
  $fFromJSONSourceType1 ::
    [Data.Aeson.Types.Internal.Parser Project.SourceType]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.SourceType] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
7035eaf45a3b87c0505356e2d57bc18f
  $fFromJSONSourceType_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.SourceType]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.SourceType]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONSourceType1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONSourceType_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.SourceType]>_R)) } }) -}
8734b319bd8a10e061ac3750b4cc844b
  $fFromJSONSourceType_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.SourceType]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
75a9b971855400fde3d5fea1f3aa6d36
  $fFromJSONSource_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.Source
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.Internal.$fMonoidParser_$cmempty
                        @ Project.Source
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser Project.SourceType
                        = case ProjectJson.$fFromJSONSource6 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONSource7
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Project.SourceType>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser Project.SourceType
                                 = ProjectJson.$fFromJSONSource_$cparseJSON1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           Project.SourceType f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <Project.SourceType>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONSource_pathElem1
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Project.SourceType>_R)) } }
                      } in
                      let {
                        e :: Data.Aeson.Types.Internal.Parser [XMapTypes.XMapName]
                        = case ProjectJson.$fFromJSONSource2 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONSource3
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[XMapTypes.XMapName]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [XMapTypes.XMapName]
                                 = XMapJson.$fFromJSONXMapName_$cparseJSONList v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           [XMapTypes.XMapName] f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <[XMapTypes.XMapName]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONSource_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[XMapTypes.XMapName]>_R)) } }
                      } in
                      (\ @ (f :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f r)
                         (ks :: Data.Aeson.Types.Internal.Success Project.Source f r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0] <Project.SourceType>_R)
                         @ f
                         @ r
                         path
                         kf
                         (\ (a1 :: Project.SourceType) ->
                          e `cast`
                          (Data.Aeson.Types.Internal.N:Parser[0] <[XMapTypes.XMapName]>_R)
                            @ f
                            @ r
                            path
                            kf
                            (\ (a2 :: [XMapTypes.XMapName]) -> ks (Project.Source a1 a2))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Project.Source>_R)) }) -}
76a41e0218ab4398bc0c8a66b66d044c
  $fFromJSONSource_$cparseJSON1 ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.SourceType
  {- Arity: 1, Strictness: <S,1*U> -}
0f647b62ac9ae5edb8d9770d2f5355bb
  $fFromJSONSource_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.Source]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.Source]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONSource1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONSource_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.Source]>_R)) } }) -}
a2ec241f0d0f5f53ec052293148e6069
  $fFromJSONSource_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.Source]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
1bec20f4c7a112e89ce82ddc521861f0
  $fFromJSONSource_msg1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONSource8) -}
b89917f43f72614725797d8f67fb3c3f
  $fFromJSONSource_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONSource4) -}
42b5cf822cb6710199898e21b9bf1a37
  $fFromJSONSource_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONSource2) -}
8a1438aa5594917918351dbf022e2fa2
  $fFromJSONSource_pathElem1 ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONSource6) -}
ebb999b0ebb62451b0cbf8fe8e39914e
  $fFromJSONUser :: Data.Aeson.Types.FromJSON.FromJSON Project.User
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.User
                  ProjectJson.$fFromJSONUser_$cparseJSON
                  ProjectJson.$fFromJSONUser_$cparseJSONList -}
48e1d6121dc9ce27a2be364461db6e73
  $fFromJSONUser1 ::
    [Data.Aeson.Types.Internal.Parser Project.User]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Project.User] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
912f1b192a71ff847884187986e26ecc
  $fFromJSONUser2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   "accessToProjects"#) -}
98ff7dd76bce19b54291196b8f532382
  $fFromJSONUser3 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [Project.ProjectName] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             [Project.ProjectName] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONUser_msg3) -}
88e24bf64f66947c001eef5d6eeaa2ce
  $fFromJSONUser4 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONUser2 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONSource5 }) -}
dcc8e23a9c8a15ee4a01904dca911c6c
  $fFromJSONUser5 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "userId"#) -}
7427df1bc36c1b430b6a7a4cf6641f50
  $fFromJSONUser6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Text"#) -}
efbf7a4bcf5f56cdd48db5b7db491f40
  $fFromJSONUser7 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success Data.Text.Internal.Text f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success
                             Data.Text.Internal.Text f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONUser_msg1) -}
e2c216c8f083aeda1e5074e67b64e0eb
  $fFromJSONUser8 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONUser5 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONSource5 }) -}
196e8fe61bbbec285ecccb3aaaef79f1
  $fFromJSONUser_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Project.User
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.Internal.$fMonoidParser_$cmempty @ Project.User
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser Data.Text.Internal.Text
                        = case ProjectJson.$fFromJSONUser5 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONUser7
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Data.Text.Internal.Text>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser Data.Text.Internal.Text
                                 = case v1 of wild2 {
                                     DEFAULT
                                     -> Data.Aeson.Types.FromJSON.typeMismatch
                                          @ Data.Text.Internal.Text
                                          ProjectJson.$fFromJSONUser6
                                          wild2
                                     Data.Aeson.Types.Internal.String txt
                                     -> (\ @ (f :: * -> *)
                                           @ r
                                           (_path :: Data.Aeson.Types.Internal.JSONPath)
                                           (_kf :: Data.Aeson.Types.Internal.Failure f r)
                                           (ks :: Data.Aeson.Types.Internal.Success
                                                    Data.Text.Internal.Text f r) ->
                                         ks txt)
                                          `cast`
                                        (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                                  <Data.Text.Internal.Text>_R)) }
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           Data.Text.Internal.Text f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <Data.Text.Internal.Text>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONUser_pathElem1
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <Data.Text.Internal.Text>_R)) } }
                      } in
                      let {
                        e :: Data.Aeson.Types.Internal.Parser [Project.ProjectName]
                        = case ProjectJson.$fFromJSONUser2 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONUser3
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[Project.ProjectName]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [Project.ProjectName]
                                 = ProjectJson.$fFromJSONAllProjects_$cparseJSONList1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success
                                           [Project.ProjectName] f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <[Project.ProjectName]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONUser_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[Project.ProjectName]>_R)) } }
                      } in
                      (\ @ (f :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f r)
                         (ks :: Data.Aeson.Types.Internal.Success Project.User f r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0] <Data.Text.Internal.Text>_R)
                         @ f
                         @ r
                         path
                         kf
                         (\ (a1 :: Data.Text.Internal.Text) ->
                          e `cast`
                          (Data.Aeson.Types.Internal.N:Parser[0] <[Project.ProjectName]>_R)
                            @ f
                            @ r
                            path
                            kf
                            (\ (a2 :: [Project.ProjectName]) -> ks (Project.User a1 a2))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <Project.User>_R)) }) -}
f650db26ac914da0d2fac7c7044851e3
  $fFromJSONUser_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Project.User]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Project.User]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONUser1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONUser_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Project.User]>_R)) } }) -}
d088607be47ae6be4c137641454526a5
  $fFromJSONUser_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Project.User]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
cabf323aa769f93c3cdbefe8ec689b25
  $fFromJSONUser_msg1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONUser8) -}
6ad6dd2ecb2917c340d1c7f16c0daf47
  $fFromJSONUser_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONUser4) -}
244f31c3f81f1a705e107bf741b0644d
  $fFromJSONUser_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONUser2) -}
09d06bc2da79bac71de1c6ffe201e23a
  $fFromJSONUser_pathElem1 ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONUser5) -}
f80feba9c1da8a6de3956f30d1115915
  $fFromJSONView :: Data.Aeson.Types.FromJSON.FromJSON View.View
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.View
                  ProjectJson.$fFromJSONView_$cparseJSON
                  ProjectJson.$fFromJSONView_$cparseJSONList -}
03c1ad967dac42224f17429d4e9933cc
  $fFromJSONView1 ::
    [Data.Aeson.Types.Internal.Parser View.View]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.View] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
9a14f125d7831ff18646850c27b443ac
  $fFromJSONView2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "rows"#) -}
337174d06db6abf0b3cbf54b8cf4a583
  $fFromJSONView3 ::
    [Data.Aeson.Types.Internal.Parser View.ViewRow]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewRow] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
738e6c8957be4ff36df8115a2c5bc2b8
  $fFromJSONView4 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [View.ViewRow] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success [View.ViewRow] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONView_msg3) -}
3263193ebc5d77544eee4d55f7c071e4
  $fFromJSONView5 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONView2 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONSource5 }) -}
f7aebc5e10f39aa61f313acd29ca5fdc
  $fFromJSONView6 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "viewName"#) -}
6ad84f3eb14cd2743dc309e5ba042bc0
  $fFromJSONView7 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success View.ViewName f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success View.ViewName f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONView_msg1) -}
a3439748e9f9ac69b172ecf58bc79b4f
  $fFromJSONView8 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONView6 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONSource5 }) -}
6b7e5a2b2ade67fdc5bedec8ff4161fa
  $fFromJSONViewItem ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewItem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewItem
                  ProjectJson.$fFromJSONViewItem_$cparseJSON
                  ProjectJson.$fFromJSONViewItem_$cparseJSONList -}
93e244ba5be2fe4dc56f3de224738e1e
  $fFromJSONViewItem1 ::
    [Data.Aeson.Types.Internal.Parser View.ViewItem]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewItem] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
35d4d010ad8dda78b43e2918341897a7
  $fFromJSONViewItem_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewItem
  {- Arity: 1, Strictness: <S,1*U> -}
d701ba8cefae694d645c5ee95665be72
  $fFromJSONViewItem_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewItem]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewItem]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONViewItem1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONViewItem_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewItem]>_R)) } }) -}
f199abcdfa24ed5e22a88b3c1ebdcd9b
  $fFromJSONViewItem_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewItem]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
3d888ce2c51e003a9ef88c93c641a3f7
  $fFromJSONViewLabel ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewLabel
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewLabel
                  ProjectJson.$fFromJSONViewLabel_$cparseJSON
                  ProjectJson.$fFromJSONViewLabel_$cparseJSONList -}
4a58e84c834e0af4c96221b565c1c876
  $fFromJSONViewLabel1 ::
    [Data.Aeson.Types.Internal.Parser View.ViewLabel]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewLabel] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
6728070435e60ab426ef3fc9941e80a9
  $fFromJSONViewLabel2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success View.ViewLabel f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success View.ViewLabel f r) ->
                 case ds of wild {
                   DEFAULT
                   -> eta1
                        (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement eta)
                        ProjectJson.$fFromJSONApplicationName3
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (View.N:ViewLabel[0])) }) -}
d9f3f0b5447a38d46dfc1867d69da9de
  $fFromJSONViewLabel_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewLabel
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONViewLabel2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <View.ViewLabel>_R)) -}
bd1d9cf429e07a7138dcd3fa233bf511
  $fFromJSONViewLabel_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewLabel]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewLabel]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONViewLabel1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONViewLabel_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewLabel]>_R)) } }) -}
1ab6d8cd6e64eef51c334914b56c48f7
  $fFromJSONViewLabel_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewLabel]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
c2bf78e69c12748d506c147902990cc7
  $fFromJSONViewName ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewName
                  ProjectJson.$fFromJSONViewName_$cparseJSON
                  ProjectJson.$fFromJSONViewName_$cparseJSONList -}
789cf76aadff1af22b634934fe644570
  $fFromJSONViewName1 ::
    [Data.Aeson.Types.Internal.Parser View.ViewName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [View.ViewName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
dd6b7b848c3c6b5e36a376f82429771f
  $fFromJSONViewName2 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success View.ViewName f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success View.ViewName f r) ->
                 case ds of wild {
                   DEFAULT
                   -> eta1
                        (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement eta)
                        ProjectJson.$fFromJSONApplicationName3
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (View.N:ViewName[0])) }) -}
6c951c88274e5dbf57eb5cd27e1d7cec
  $fFromJSONViewName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewName
  {- Arity: 4, Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fFromJSONViewName2
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <View.ViewName>_R)) -}
6a9e5c73aca80a6948c616968255f9d8
  $fFromJSONViewName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewName]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONViewName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONViewName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewName]>_R)) } }) -}
f558e443472f4717f44d4736769d5927
  $fFromJSONViewName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewName]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
f27292838fac57a6424e4c092dfbc235
  $fFromJSONViewRow ::
    Data.Aeson.Types.FromJSON.FromJSON View.ViewRow
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewRow
                  ProjectJson.$fFromJSONViewRow_$cparseJSON
                  ProjectJson.$fFromJSONView_$cparseJSONList1 -}
dc9c7642f8bba64f39956eda804db1f8
  $fFromJSONViewRow1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "items"#) -}
e93b6f349c9693d12664e365347643cc
  $fFromJSONViewRow2 ::
    Data.Aeson.Types.Internal.JSONPath
    -> Data.Aeson.Types.Internal.Failure f r
    -> Data.Aeson.Types.Internal.Success [View.ViewItem] f r
    -> f r
  {- Arity: 3,
     Unfolding: (\ @ (f :: * -> *)
                   @ r
                   (path :: Data.Aeson.Types.Internal.JSONPath)
                   (kf :: Data.Aeson.Types.Internal.Failure f r)
                   (_ks :: Data.Aeson.Types.Internal.Success [View.ViewItem] f r) ->
                 kf
                   (GHC.List.reverse @ Data.Aeson.Types.Internal.JSONPathElement path)
                   ProjectJson.$fFromJSONViewRow_msg3) -}
ed47cb98f59f0992db81690f42c39ca2
  $fFromJSONViewRow3 :: [GHC.Types.Char]
  {- Unfolding: (case Data.Text.Show.$w$cshow
                        ProjectJson.$fFromJSONViewRow1 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                   ProjectJson.$fFromJSONSource5 }) -}
3a5606f96713c718ed678f9abed058ec
  $fFromJSONViewRow_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.ViewRow
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.Internal.$fMonoidParser_$cmempty @ View.ViewRow
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser [View.ViewItem]
                        = case ProjectJson.$fFromJSONViewRow1 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONViewRow2
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewItem]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [View.ViewItem]
                                 = ProjectJson.$fFromJSONViewItem_$cparseJSONList v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success [View.ViewItem] f r) ->
                                p `cast`
                                (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewItem]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONViewRow_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[View.ViewItem]>_R)) } }
                      } in
                      (\ @ (f21 :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f21 r)
                         (ks :: Data.Aeson.Types.Internal.Success View.ViewRow f21 r) ->
                       m `cast`
                       (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewItem]>_R)
                         @ f21
                         @ r
                         path
                         kf
                         (\ (a1 :: [View.ViewItem]) ->
                          ks a1 `cast` (Sym (View.N:ViewRow[0]))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <View.ViewRow>_R)) }) -}
d66103f57b4be88b413e5745cac4b6f0
  $fFromJSONViewRow_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONViewRow3) -}
f861bf2e459e555bc6562b3224e5fb60
  $fFromJSONViewRow_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONViewRow1) -}
f86bfee92740fc36ce926492fe67200f
  $fFromJSONView_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser View.View
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.Internal.$fMonoidParser_$cmempty @ View.View
                   Data.Aeson.Types.Internal.Object v
                   -> let {
                        m :: Data.Aeson.Types.Internal.Parser View.ViewName
                        = case ProjectJson.$fFromJSONView6 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONView7
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <View.ViewName>_R))
                            GHC.Base.Just v1
                            -> (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success View.ViewName f r) ->
                                case v1 of wild2 {
                                  DEFAULT
                                  -> kf
                                       (GHC.List.reverse1
                                          @ Data.Aeson.Types.Internal.JSONPathElement
                                          (GHC.Types.:
                                             @ Data.Aeson.Types.Internal.JSONPathElement
                                             ProjectJson.$fFromJSONView_pathElem1
                                             path)
                                          (GHC.Types.[]
                                             @ Data.Aeson.Types.Internal.JSONPathElement))
                                       ProjectJson.$fFromJSONApplicationName3
                                  Data.Aeson.Types.Internal.String v2
                                  -> ks v2 `cast` (Sym (View.N:ViewName[0])) })
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <View.ViewName>_R)) } }
                      } in
                      let {
                        e :: Data.Aeson.Types.Internal.Parser [View.ViewRow]
                        = case ProjectJson.$fFromJSONView2 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                          case Data.Aeson.Types.FromJSON.$w$slookup
                                 @ Data.Aeson.Types.Internal.Value
                                 ww1
                                 ww2
                                 ww3
                                 v of wild1 {
                            GHC.Base.Nothing
                            -> ProjectJson.$fFromJSONView4
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewRow]>_R))
                            GHC.Base.Just v1
                            -> let {
                                 p :: Data.Aeson.Types.Internal.Parser [View.ViewRow]
                                 = ProjectJson.$fFromJSONView_$cparseJSONList1 v1
                               } in
                               (\ @ (f :: * -> *)
                                  @ r
                                  (path :: Data.Aeson.Types.Internal.JSONPath)
                                  (kf :: Data.Aeson.Types.Internal.Failure f r)
                                  (ks :: Data.Aeson.Types.Internal.Success [View.ViewRow] f r) ->
                                p `cast` (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewRow]>_R)
                                  @ f
                                  @ r
                                  (GHC.Types.:
                                     @ Data.Aeson.Types.Internal.JSONPathElement
                                     ProjectJson.$fFromJSONView_pathElem
                                     path)
                                  kf
                                  ks)
                                 `cast`
                               (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                         <[View.ViewRow]>_R)) } }
                      } in
                      (\ @ (f :: * -> *)
                         @ r
                         (path :: Data.Aeson.Types.Internal.JSONPath)
                         (kf :: Data.Aeson.Types.Internal.Failure f r)
                         (ks :: Data.Aeson.Types.Internal.Success View.View f r) ->
                       m `cast` (Data.Aeson.Types.Internal.N:Parser[0] <View.ViewName>_R)
                         @ f
                         @ r
                         path
                         kf
                         (\ (a1 :: View.ViewName) ->
                          e `cast` (Data.Aeson.Types.Internal.N:Parser[0] <[View.ViewRow]>_R)
                            @ f
                            @ r
                            path
                            kf
                            (\ (a2 :: [View.ViewRow]) -> ks (View.View a1 a2))))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0] <View.View>_R)) }) -}
77c330612f1c93c47505eee1cba07807
  $fFromJSONView_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.View]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.View]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONView1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONView_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.View]>_R)) } }) -}
e97e29f889d2af8821331495e8fed181
  $fFromJSONView_$cparseJSONList1 ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [View.ViewRow]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [View.ViewRow]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONView3
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONView_go1 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[View.ViewRow]>_R)) } }) -}
1c1f847e1944b0516a06c9896e608b19
  $fFromJSONView_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.View]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
94a5800470ac28f326e9f1e61b341624
  $fFromJSONView_go1 ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser View.ViewRow]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
ff4ae46a3f1fa493cdcbe59ff608682f
  $fFromJSONView_msg1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONView8) -}
6fe5af1d2e6ad6838ff43a0e5dbf23b1
  $fFromJSONView_msg3 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "key "#
                   ProjectJson.$fFromJSONView5) -}
f0e7b6d185a573289b7ec62d54f10bc8
  $fFromJSONView_pathElem ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONView2) -}
d5ced51d9b84b915ef05fecf956b504c
  $fFromJSONView_pathElem1 ::
    Data.Aeson.Types.Internal.JSONPathElement
  {- Unfolding: (Data.Aeson.Types.Internal.Key
                   ProjectJson.$fFromJSONView6) -}
7d95c7083f5dca4923074954b8a585e9
  $fFromJSONXFormula ::
    Data.Aeson.Types.FromJSON.FromJSON Formula.XFormula
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Formula.XFormula
                  ProjectJson.$fFromJSONXFormula_$cparseJSON
                  ProjectJson.$fFromJSONXFormula_$cparseJSONList -}
8161189f281a5c41abdda313633861ae
  $fFromJSONXFormula1 ::
    [Data.Aeson.Types.Internal.Parser Formula.XFormula]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [Formula.XFormula] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
ff0ec5156a6c8cba5fadd216415b57aa
  $fFromJSONXFormula_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser Formula.XFormula
  {- Arity: 1, Strictness: <S,1*U> -}
74a10402e725a9db3a2344db4d86df3f
  $fFromJSONXFormula_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [Formula.XFormula]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [Formula.XFormula]
                        ProjectJson.$fFromJSONAllProjects2
                        wild
                   Data.Aeson.Types.Internal.Array a1
                   -> case a1 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (ProjectJson.$fFromJSONXFormula1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds1 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          ProjectJson.$fFromJSONXFormula_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[Formula.XFormula]>_R)) } }) -}
25466442deb43182ffa27f3c48c57efe
  $fFromJSONXFormula_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser Formula.XFormula]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
1c3b3409973e7b6e866f165fcc56ada9
  $fToJSONAllProjects ::
    Data.Aeson.Types.ToJSON.ToJSON Project.AllProjects
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.AllProjects
                  ProjectJson.$fToJSONAllProjects_$ctoJSON
                  ProjectJson.$fToJSONAllProjects_$ctoEncoding
                  ProjectJson.$fToJSONAllProjects_$ctoJSONList1
                  ProjectJson.$fToJSONAllProjects_$ctoEncodingList -}
55b9c2260e13b6bed32453b9805070a5
  $fToJSONAllProjects_$ctoEncoding ::
    Project.AllProjects -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.AllProjects) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONAllProjects_$ctoJSON eta)) -}
5fd9860b135f71feac2c1f5b44ba0f0d
  $fToJSONAllProjects_$ctoEncodingList ::
    [Project.AllProjects] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.AllProjects]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONAllProjects_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.AllProjects
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.AllProjects)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONAllProjects_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.AllProjects>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
f7573bb76f487e731b447f2c974eef84
  $fToJSONAllProjects_$ctoJSON ::
    Project.AllProjects -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2,
     Unfolding: InlineRule (0, True, True)
                ProjectJson.$fToJSONAllProjects_$ctoJSONList
                  `cast`
                (Sym (Project.N:AllProjects[0])
                 ->_R <Data.Aeson.Types.Internal.Value>_R) -}
25e55937f078390289137f378a2cda7a
  $fToJSONAllProjects_$ctoJSONList ::
    [Project.ProjectName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.ProjectName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.ProjectName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.ProjectName
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (Project.N:ProjectName[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
47fcaeebf87edfae67e5ed7acf6bfb4c
  $fToJSONAllProjects_$ctoJSONList1 ::
    [Project.AllProjects] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.AllProjects]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.AllProjects
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.AllProjects
                                       c
                                       ProjectJson.$fToJSONAllProjects_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
3aa47344ace2892a9fb0a3c94650a29e
  $fToJSONApplicationName ::
    Data.Aeson.Types.ToJSON.ToJSON ApplicationTypes.ApplicationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ApplicationTypes.ApplicationName
                  ProjectJson.$fToJSONApplicationName_$ctoJSON
                  ProjectJson.$fToJSONApplicationName_$ctoEncoding
                  ProjectJson.$fToJSONApplicationName_$ctoJSONList
                  ProjectJson.$fToJSONApplicationName_$ctoEncodingList -}
f77a4afc9fe12a2c1bf39a555bcc5dc9
  $fToJSONApplicationName_$ctoEncoding ::
    ApplicationTypes.ApplicationName
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*H>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: ApplicationTypes.ApplicationName) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONApplicationName_$ctoJSON eta)) -}
a03376f3ee4183c566e618d768198173
  $fToJSONApplicationName_$ctoEncodingList ::
    [ApplicationTypes.ApplicationName]
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [ApplicationTypes.ApplicationName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONApplicationName_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ ApplicationTypes.ApplicationName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: ApplicationTypes.ApplicationName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONApplicationName_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<ApplicationTypes.ApplicationName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
0363a6f92297a96d73a582695fe06a75
  $fToJSONApplicationName_$ctoJSON ::
    ApplicationTypes.ApplicationName -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*H>m3, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ApplicationTypes.ApplicationName) ->
                 case w of w1 { ApplicationTypes.Negate ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ Data.Text.Internal.Text
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         TextEnums.$wouter
                           ipv1
                           4#
                           ApplicationTypes.$fReadApplicationName4
                           0#
                           ipv }) of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of dt { Data.Text.Internal.Text ipv2 ipv3 ipv4 ->
                 Data.Aeson.Types.Internal.String dt } } }) -}
00804791459c8f26ff69b75b660bc068
  $fToJSONApplicationName_$ctoJSONList ::
    [ApplicationTypes.ApplicationName]
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [ApplicationTypes.ApplicationName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ ApplicationTypes.ApplicationName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ ApplicationTypes.ApplicationName
                                       c
                                       ProjectJson.$fToJSONApplicationName_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
380c705c79c9f3d399b9247fb380f5c3
  $fToJSONCalculation ::
    Data.Aeson.Types.ToJSON.ToJSON Calculation.Calculation
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.Calculation
                  ProjectJson.$fToJSONCalculation_$ctoJSON
                  ProjectJson.$fToJSONCalculation_$ctoEncoding
                  ProjectJson.$fToJSONCalculation_$ctoJSONList
                  ProjectJson.$fToJSONCalculation_$ctoEncodingList -}
eb01d84d82b1bcb32b3d57b5da418152
  $fToJSONCalculation1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "operationMode"#) -}
a71d118b0aa62b3cc6b15ec1ce9ffce2
  $fToJSONCalculation2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "formula"#) -}
776afa76c04b60452b2fba921426e6f8
  $fToJSONCalculation3 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "resultName"#) -}
7530010cfe782d4abec8846641b3dd19
  $fToJSONCalculation4 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "calculationName"#) -}
dd91a3a264d4c07277cd53a48624ad10
  $fToJSONCalculationFormulaText ::
    Data.Aeson.Types.ToJSON.ToJSON Calculation.CalculationFormulaText
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.CalculationFormulaText
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (Calculation.N:CalculationFormulaText[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: Calculation.CalculationFormulaText) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (Calculation.N:CalculationFormulaText[0])))
                  ProjectJson.$fToJSONCalculationFormulaText_$ctoJSONList
                  ProjectJson.$fToJSONCalculationFormulaText_$ctoEncodingList -}
04120bbd30d3ec49c8944b49490897c6
  $fToJSONCalculationFormulaText_$ctoEncodingList ::
    [Calculation.CalculationFormulaText]
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.CalculationFormulaText]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (Calculation.N:CalculationFormulaText[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Calculation.CalculationFormulaText
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Calculation.CalculationFormulaText)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (Calculation.N:CalculationFormulaText[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Calculation.CalculationFormulaText>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
2d3f430a9ace23f9c7d9d4502219737d
  $fToJSONCalculationFormulaText_$ctoJSONList ::
    [Calculation.CalculationFormulaText]
    -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.CalculationFormulaText]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Calculation.CalculationFormulaText
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Calculation.CalculationFormulaText
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (Calculation.N:CalculationFormulaText[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
e6235348c03223901427514f2c0aaaf5
  $fToJSONCalculationName ::
    Data.Aeson.Types.ToJSON.ToJSON Calculation.CalculationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.CalculationName
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (Calculation.N:CalculationName[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: Calculation.CalculationName) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (Calculation.N:CalculationName[0])))
                  ProjectJson.$fToJSONCalculationName_$ctoJSONList
                  ProjectJson.$fToJSONCalculationName_$ctoEncodingList -}
fbbf3fd6521135abeda473a2d744530d
  $fToJSONCalculationName_$ctoEncodingList ::
    [Calculation.CalculationName]
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.CalculationName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (Calculation.N:CalculationName[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Calculation.CalculationName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Calculation.CalculationName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (Calculation.N:CalculationName[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Calculation.CalculationName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
b66f7ea28dc7432ac64626f0351bd425
  $fToJSONCalculationName_$ctoJSONList ::
    [Calculation.CalculationName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.CalculationName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Calculation.CalculationName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Calculation.CalculationName
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (Calculation.N:CalculationName[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
35ff179203a0e74419daf58adc8650a1
  $fToJSONCalculationSource ::
    Data.Aeson.Types.ToJSON.ToJSON Calculation.CalculationSource
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.CalculationSource
                  ProjectJson.$fToJSONCalculationSource_$ctoJSON
                  ProjectJson.$fToJSONCalculationSource_$ctoEncoding
                  ProjectJson.$fToJSONCalculationSource_$ctoJSONList
                  ProjectJson.$fToJSONCalculationSource_$ctoEncodingList -}
91471fc3bb944ef52a91e8cc08f8146b
  $fToJSONCalculationSource1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "formulaText"#) -}
8fb1b1cd790047721b7b5b90b0656da2
  $fToJSONCalculationSource_$ctoEncoding ::
    Calculation.CalculationSource
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U,U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Calculation.CalculationSource) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculationSource_$ctoJSON eta)) -}
ead36d9d6c6ed9c52ba55d31958bb379
  $fToJSONCalculationSource_$ctoEncodingList ::
    [Calculation.CalculationSource]
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.CalculationSource]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculationSource_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Calculation.CalculationSource
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Calculation.CalculationSource)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculationSource_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Calculation.CalculationSource>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
f4c2eb8c4a06f65b0a99601ea24783c4
  $fToJSONCalculationSource_$ctoJSON ::
    Calculation.CalculationSource -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U,U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Calculation.CalculationSource) ->
                 case w of ww { Calculation.CalculationSource ww1 ww2 ww3 ww4 ->
                 case ProjectJson.$w$ctoJSON3 ww1 ww2 ww3 ww4 of ww5 { Unit# ww6 ->
                 Data.Aeson.Types.Internal.Object ww6 } }) -}
28443676259b0921cdf23086322a61ba
  $fToJSONCalculationSource_$ctoJSONList ::
    [Calculation.CalculationSource] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.CalculationSource]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Calculation.CalculationSource
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Calculation.CalculationSource
                                       c
                                       ProjectJson.$fToJSONCalculationSource_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
16ad7b4ef50d0018f3957b64751a7001
  $fToJSONCalculation_$ctoEncoding ::
    Calculation.Calculation -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Calculation.Calculation) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculation_$ctoJSON eta)) -}
0561a43f26b6f5eed0591d237a16a645
  $fToJSONCalculation_$ctoEncodingList ::
    [Calculation.Calculation] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.Calculation]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculation_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Calculation.Calculation
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Calculation.Calculation)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculation_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Calculation.Calculation>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
8edb7e1b2887ee86f062acdc67c6b2ef
  $fToJSONCalculation_$ctoJSON ::
    Calculation.Calculation -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>m1,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Calculation.Calculation) ->
                 case w of ww { Calculation.Calculation ww1 ww2 ww3 ww4 ->
                 case ProjectJson.$w$ctoJSON ww1 ww2 ww3 ww4 of ww5 { Unit# ww6 ->
                 Data.Aeson.Types.Internal.Object ww6 } }) -}
cd925fae6dbb8c5fd1352b3e27100a82
  $fToJSONCalculation_$ctoJSON1 ::
    XFunction.OperationMode -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m3, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: XFunction.OperationMode) ->
                 case ProjectJson.$w$ctoJSON1 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.String ww1 }) -}
6f5ac2775087c960c100c9eae4c59431
  $fToJSONCalculation_$ctoJSON2 ::
    Formula.XFormula -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Formula.XFormula) ->
                 case ProjectJson.$w$ctoJSON2 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
afc6c6c7c41ad3c9f12093118664674e
  $fToJSONCalculation_$ctoJSONList ::
    [Calculation.Calculation] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.Calculation]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Calculation.Calculation
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Calculation.Calculation
                                       c
                                       ProjectJson.$fToJSONCalculation_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
423c8a107be15e9b03f949fb53680cd2
  $fToJSONFunctions ::
    Data.Aeson.Types.ToJSON.ToJSON Calculation.Functions
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Calculation.Functions
                  ProjectJson.$fToJSONFunctions_$ctoJSON
                  ProjectJson.$fToJSONFunctions_$ctoEncoding
                  ProjectJson.$fToJSONFunctions_$ctoJSONList
                  ProjectJson.$fToJSONFunctions_$ctoEncodingList -}
f6a55ed5c4ad4febffb64e8d5ae0bc80
  $fToJSONFunctions1 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
5e2c3991823b3b5ed4a6e5380fba8e04
  $fToJSONFunctions2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "applications"#) -}
63ddf2f18c7b30c96f73ebc0d1d24f9e
  $fToJSONFunctions3 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
7d33dad78a014d5f4f9c07cf9b6921cd
  $fToJSONFunctions4 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
f4ebd082f2c088597442945a124409f2
  $fToJSONFunctions5 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "operations"#) -}
11bedd5e77f9e6197506cf25ac6c523c
  $fToJSONFunctions_$ctoEncoding ::
    Calculation.Functions -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Calculation.Functions) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONFunctions_$ctoJSON eta)) -}
3553210594db5535566fbe760c3f190e
  $fToJSONFunctions_$ctoEncodingList ::
    [Calculation.Functions] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.Functions]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONFunctions_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Calculation.Functions
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Calculation.Functions)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONFunctions_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Calculation.Functions>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
684e8dc70ce142e93ed4a46a07b62121
  $fToJSONFunctions_$ctoJSON ::
    Calculation.Functions -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Calculation.Functions) ->
                 case w of ww { Calculation.Functions ww1 ww2 ->
                 case ProjectJson.$w$ctoJSON4 ww1 ww2 of ww3 { Unit# ww4 ->
                 Data.Aeson.Types.Internal.Object ww4 } }) -}
85b32bf4d933da8762bf33ece0e7a3c0
  $fToJSONFunctions_$ctoJSON1 ::
    OperationTypes.OperationName -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m3, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: OperationTypes.OperationName) ->
                 case ProjectJson.$w$ctoJSON5 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.String ww1 }) -}
11a402b7c1a85c433948b5c61b578e31
  $fToJSONFunctions_$ctoJSONList ::
    [Calculation.Functions] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Calculation.Functions]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Calculation.Functions
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Calculation.Functions
                                       c
                                       ProjectJson.$fToJSONFunctions_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
4ddf4098c252fdfec85c6b0298b39733
  $fToJSONOperationMode ::
    Data.Aeson.Types.ToJSON.ToJSON XFunction.OperationMode
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XFunction.OperationMode
                  ProjectJson.$fToJSONCalculation_$ctoJSON1
                  ProjectJson.$fToJSONOperationMode_$ctoEncoding
                  ProjectJson.$fToJSONOperationMode_$ctoJSONList
                  ProjectJson.$fToJSONOperationMode_$ctoEncodingList -}
b03eacf4ac1ab0b5ff45151f333d4f5d
  $fToJSONOperationMode_$ctoEncoding ::
    XFunction.OperationMode -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XFunction.OperationMode) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculation_$ctoJSON1 eta)) -}
b2196f06d44c73dc66f9d722759de4e9
  $fToJSONOperationMode_$ctoEncodingList ::
    [XFunction.OperationMode] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XFunction.OperationMode]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculation_$ctoJSON1 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XFunction.OperationMode
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XFunction.OperationMode)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculation_$ctoJSON1 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XFunction.OperationMode>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
58dbcd272ddeec7e888ec2fa8ae12f4a
  $fToJSONOperationMode_$ctoJSONList ::
    [XFunction.OperationMode] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XFunction.OperationMode]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XFunction.OperationMode
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XFunction.OperationMode
                                       c
                                       ProjectJson.$fToJSONCalculation_$ctoJSON1)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
36ab7f9883974590805eb1ace7fe7b78
  $fToJSONOperationName ::
    Data.Aeson.Types.ToJSON.ToJSON OperationTypes.OperationName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ OperationTypes.OperationName
                  ProjectJson.$fToJSONFunctions_$ctoJSON1
                  ProjectJson.$fToJSONOperationName_$ctoEncoding
                  ProjectJson.$fToJSONOperationName_$ctoJSONList
                  ProjectJson.$fToJSONOperationName_$ctoEncodingList -}
9ab9cedbc0d519c24098f10235d132e0
  $fToJSONOperationName_$ctoEncoding ::
    OperationTypes.OperationName
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: OperationTypes.OperationName) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONFunctions_$ctoJSON1 eta)) -}
124799875ab33e09b65d568e22755641
  $fToJSONOperationName_$ctoEncodingList ::
    [OperationTypes.OperationName]
    -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [OperationTypes.OperationName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONFunctions_$ctoJSON1 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ OperationTypes.OperationName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: OperationTypes.OperationName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONFunctions_$ctoJSON1 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<OperationTypes.OperationName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
d23eadcde597546349341c0dc7521794
  $fToJSONOperationName_$ctoJSONList ::
    [OperationTypes.OperationName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [OperationTypes.OperationName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ OperationTypes.OperationName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ OperationTypes.OperationName
                                       c
                                       ProjectJson.$fToJSONFunctions_$ctoJSON1)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
70f5e2195c69f724214bc30f22c4bdee
  $fToJSONProject :: Data.Aeson.Types.ToJSON.ToJSON Project.Project
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Project
                  ProjectJson.$fToJSONProject_$ctoJSON
                  ProjectJson.$fToJSONProject_$ctoEncoding
                  ProjectJson.$fToJSONProject_$ctoJSONList
                  ProjectJson.$fToJSONProject_$ctoEncodingList -}
e1068ee95ec88d2112ac8c2dc9fe4ebe
  $fToJSONProjectName ::
    Data.Aeson.Types.ToJSON.ToJSON Project.ProjectName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.ProjectName
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (Project.N:ProjectName[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: Project.ProjectName) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (Project.N:ProjectName[0])))
                  ProjectJson.$fToJSONAllProjects_$ctoJSONList
                  ProjectJson.$fToJSONProjectName_$ctoEncodingList -}
c53e1d52f2302f6d3e8b1721cac41033
  $fToJSONProjectName_$ctoEncodingList ::
    [Project.ProjectName] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.ProjectName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (Project.N:ProjectName[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.ProjectName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.ProjectName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (Project.N:ProjectName[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.ProjectName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
95ed3406a27d1d169aadac9364b9dd63
  $fToJSONProject_$ctoEncoding ::
    Project.Project -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.Project) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONProject_$ctoJSON eta)) -}
4358eed8dd36ec10fffd685355cf0c17
  $fToJSONProject_$ctoEncodingList ::
    [Project.Project] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Project]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONProject_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.Project
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.Project)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONProject_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.Project>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
ae8a75fef6c558904a54a58ebc43b072
  $fToJSONProject_$ctoJSON ::
    Project.Project -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U,1*U,1*U)>m1,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.Project) ->
                 case w of ww { Project.Project ww1 ww2 ww3 ww4 ->
                 case ProjectJson.$w$ctoJSON6 ww1 ww2 ww3 ww4 of ww5 { Unit# ww6 ->
                 Data.Aeson.Types.Internal.Object ww6 } }) -}
dcc9ff6bc95a1ea4d881f3be6c3a6ebb
  $fToJSONProject_$ctoJSONList ::
    [Project.Project] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Project]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.Project
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.Project
                                       c
                                       ProjectJson.$fToJSONProject_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
c1c89693181f67972dc708679aaf284b
  $fToJSONSource :: Data.Aeson.Types.ToJSON.ToJSON Project.Source
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.Source
                  ProjectJson.$fToJSONSource_$ctoJSON
                  ProjectJson.$fToJSONSource_$ctoEncoding
                  ProjectJson.$fToJSONSource_$ctoJSONList
                  ProjectJson.$fToJSONSource_$ctoEncodingList -}
28ca6db24a6ac1288350f2785746e0ed
  $fToJSONSource1 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
1068fb75d83b7d224582d75091c16d01
  $fToJSONSource10 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        ProjectJson.$fToJSONSource11
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 Data.Aeson.Types.Internal.Object dt }) -}
fe6a7439f04b5074ddba423e4b7cc17a
  $fToJSONSource11 :: [Data.Aeson.Types.Internal.Pair]
  {- Unfolding: (GHC.Types.:
                   @ Data.Aeson.Types.Internal.Pair
                   ProjectJson.$fToJSONSource12
                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)) -}
bd3fdfbf5eb25bd5d389d6c07868db51
  $fToJSONSource12 ::
    (Data.Text.Internal.Text, Data.Aeson.Types.Internal.Value)
  {- Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONSource13)) -}
ef545faa51f97324603b56a0c42cf1b5
  $fToJSONSource13 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "fileSource"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
34552917502fcf32dda91da1f2d0c375
  $fToJSONSource2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "url"#) -}
4b934d16ea3fcf4aea3de6e562a5bed4
  $fToJSONSource3 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONSource4)) -}
d4e613556a4ac3f06844ffc6320e1dae
  $fToJSONSource4 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "httpSource"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
21e279de3e4c7a918e9114d2cb765d84
  $fToJSONSource5 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "type"#) -}
e75b3adc54153868b133580fad94cefc
  $fToJSONSource6 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "sqlQuery"#) -}
7a63d3ca640611de30f4d6548aab5110
  $fToJSONSource7 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   "connectionString"#) -}
599d770003a9da4e886a55cd3086cf4f
  $fToJSONSource8 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONSource9)) -}
e0c173416266cc8ec0cab243791a9e3c
  $fToJSONSource9 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "odbcSource"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
b6321dc1a8394220d0c00aeebc323fea
  $fToJSONSourceType ::
    Data.Aeson.Types.ToJSON.ToJSON Project.SourceType
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.SourceType
                  ProjectJson.$fToJSONSource_$ctoJSON1
                  ProjectJson.$fToJSONSourceType_$ctoEncoding
                  ProjectJson.$fToJSONSourceType_$ctoJSONList
                  ProjectJson.$fToJSONSourceType_$ctoEncodingList -}
b0a434493abb126f906a6715b10be023
  $fToJSONSourceType_$ctoEncoding ::
    Project.SourceType -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.SourceType) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONSource_$ctoJSON1 eta)) -}
52e56821103c10ef33e3dbfb6781e3be
  $fToJSONSourceType_$ctoEncodingList ::
    [Project.SourceType] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.SourceType]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONSource_$ctoJSON1 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.SourceType
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.SourceType)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONSource_$ctoJSON1 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.SourceType>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
5a7f5a020c73bea32b279247a92f0c16
  $fToJSONSourceType_$ctoJSONList ::
    [Project.SourceType] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.SourceType]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.SourceType
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.SourceType
                                       c
                                       ProjectJson.$fToJSONSource_$ctoJSON1)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
4e667d97d85b1bffe9fbaeaf82532a7b
  $fToJSONSource_$ctoEncoding ::
    Project.Source -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.Source) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONSource_$ctoJSON eta)) -}
33f806a1bacae1aa8f95f394231326c2
  $fToJSONSource_$ctoEncodingList ::
    [Project.Source] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Source]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONSource_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.Source
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.Source)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONSource_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.Source>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
706f978af7f0b059845a14ba2ea1eefa
  $fToJSONSource_$ctoJSON ::
    Project.Source -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.Source) ->
                 case w of ww { Project.Source ww1 ww2 ->
                 case ProjectJson.$w$ctoJSON7 ww1 ww2 of ww3 { Unit# ww4 ->
                 Data.Aeson.Types.Internal.Object ww4 } }) -}
f1e5f25a9f47f1fd78c22c0f2ca2cd03
  $fToJSONSource_$ctoJSON1 ::
    Project.SourceType -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Project.SourceType) ->
                 case ds of wild {
                   Project.FileSource -> ProjectJson.$fToJSONSource10
                   Project.OdbcSource connectionString sqlQuery
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONSource8
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONSource7,
                                    Data.Aeson.Types.Internal.$WString connectionString)
                                   (GHC.Types.:
                                      @ Data.Aeson.Types.Internal.Pair
                                      (ProjectJson.$fToJSONSource6,
                                       Data.Aeson.Types.Internal.$WString sqlQuery)
                                      (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair))))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      Data.Aeson.Types.Internal.Object dt }
                   Project.HttpSource url
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONSource3
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONSource2,
                                    Data.Aeson.Types.Internal.$WString url)
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      Data.Aeson.Types.Internal.Object dt } }) -}
9f4d4cc1c5bf0f06223f302b6f8580b2
  $fToJSONSource_$ctoJSONList ::
    [Project.Source] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.Source]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.Source
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.Source
                                       c
                                       ProjectJson.$fToJSONSource_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
614c7260b74c7fcc4a56f748c7523747
  $fToJSONUser :: Data.Aeson.Types.ToJSON.ToJSON Project.User
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Project.User
                  ProjectJson.$fToJSONUser_$ctoJSON
                  ProjectJson.$fToJSONUser_$ctoEncoding
                  ProjectJson.$fToJSONUser_$ctoJSONList
                  ProjectJson.$fToJSONUser_$ctoEncodingList -}
dcc204b8dd22c0b413c04ff792f75015
  $fToJSONUser1 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
267fa1a0569c5f2886267feeb77e0acc
  $fToJSONUser_$ctoEncoding ::
    Project.User -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Project.User) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONUser_$ctoJSON eta)) -}
313aa610417b7d9f699bc9081b4da6c7
  $fToJSONUser_$ctoEncodingList ::
    [Project.User] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.User]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONUser_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Project.User
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Project.User)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONUser_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Project.User>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
b964e130dc5ef678c8a325d82310f7bc
  $fToJSONUser_$ctoJSON ::
    Project.User -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Project.User) ->
                 case w of ww { Project.User ww1 ww2 ->
                 case ProjectJson.$w$ctoJSON8 ww1 ww2 of ww3 { Unit# ww4 ->
                 Data.Aeson.Types.Internal.Object ww4 } }) -}
0cba31913529258ef97958b634f954cc
  $fToJSONUser_$ctoJSONList ::
    [Project.User] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Project.User]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Project.User
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Project.User
                                       c
                                       ProjectJson.$fToJSONUser_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
26f0722f964a95bd72ec8874dc04e590
  $fToJSONView :: Data.Aeson.Types.ToJSON.ToJSON View.View
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.View
                  ProjectJson.$fToJSONView_$ctoJSON
                  ProjectJson.$fToJSONView_$ctoEncoding
                  ProjectJson.$fToJSONView_$ctoJSONList
                  ProjectJson.$fToJSONView_$ctoEncodingList -}
1e4fb0dc458d6617a1d19c158d814c31
  $fToJSONView1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "label"#) -}
2c6af43e4476947acd3bbd6124f92437
  $fToJSONView2 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONView3)) -}
e6bd25682d87d21e3450fba2a65719f8
  $fToJSONView3 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "label"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
6118bca6ef9e2d9798c026cd9695a926
  $fToJSONView4 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "mapName"#) -}
489c7fec9d48c342e34fc062a9b04449
  $fToJSONView5 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((ProjectJson.$fToJSONSource5,
                  ProjectJson.$fToJSONView6)) -}
875e1a6cfe27f54809923d35d0c75533
  $fToJSONView6 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "map"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
1de2396cf898419ad3a3296442ad56c3
  $fToJSONView7 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
3d3e7d6fe3df698bd4db2c1600d2d994
  $fToJSONView8 ::
    GHC.Types.SPEC
    -> (Data.Vector.Generic.Base.Mutable
          Data.Vector.Vector
          (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
          Data.Aeson.Types.Internal.Value,
        GHC.Types.Int)
    -> [Data.Aeson.Types.Internal.Value]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Data.Vector.Generic.Base.Mutable
             Data.Vector.Vector
             (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
             Data.Aeson.Types.Internal.Value,
           GHC.Types.Int) #)
  {- Arity: 4, Strictness: <S,1*U><L,U(U(U,U,U),U(U))><S,1*U><S,U> -}
818886810985c128e6ab914f97e0d85b
  $fToJSONViewItem :: Data.Aeson.Types.ToJSON.ToJSON View.ViewItem
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewItem
                  ProjectJson.$fToJSONView_$ctoJSON2
                  ProjectJson.$fToJSONViewItem_$ctoEncoding
                  ProjectJson.$fToJSONViewItem_$ctoJSONList
                  ProjectJson.$fToJSONViewItem_$ctoEncodingList -}
d269360c6a98c6fb592e256612c1fca7
  $fToJSONViewItem_$ctoEncoding ::
    View.ViewItem -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: View.ViewItem) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONView_$ctoJSON2 eta)) -}
d05d2baec2bb170066fdea9344df9e45
  $fToJSONViewItem_$ctoEncodingList ::
    [View.ViewItem] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewItem]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONView_$ctoJSON2 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewItem
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewItem)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONView_$ctoJSON2 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewItem>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
f603855a8d7659f551174683e016f9cf
  $fToJSONViewItem_$ctoJSONList ::
    [View.ViewItem] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewItem]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewItem
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewItem
                                       c
                                       ProjectJson.$fToJSONView_$ctoJSON2)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
b9df6455a21456ceb043dff883701758
  $fToJSONViewLabel :: Data.Aeson.Types.ToJSON.ToJSON View.ViewLabel
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewLabel
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (View.N:ViewLabel[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: View.ViewLabel) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (View.N:ViewLabel[0])))
                  ProjectJson.$fToJSONViewLabel_$ctoJSONList
                  ProjectJson.$fToJSONViewLabel_$ctoEncodingList -}
e8cf606af2dd85aa56b5adbb87ac88d4
  $fToJSONViewLabel_$ctoEncodingList ::
    [View.ViewLabel] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewLabel]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (View.N:ViewLabel[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewLabel
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewLabel)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (View.N:ViewLabel[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewLabel>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
6a713063135cff7667f5d895d5cbe1e8
  $fToJSONViewLabel_$ctoJSONList ::
    [View.ViewLabel] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewLabel]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewLabel
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewLabel
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (View.N:ViewLabel[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
5bb48244a0954c47145a66ec106fd223
  $fToJSONViewName :: Data.Aeson.Types.ToJSON.ToJSON View.ViewName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewName
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (View.N:ViewName[0]) ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: View.ViewName) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (View.N:ViewName[0])))
                  ProjectJson.$fToJSONViewName_$ctoJSONList
                  ProjectJson.$fToJSONViewName_$ctoEncodingList -}
0b80d32a5bc44811d0eb5a7a0718a995
  $fToJSONViewName_$ctoEncodingList ::
    [View.ViewName] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString x `cast` (View.N:ViewName[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (View.N:ViewName[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
b9964fda66ee586012fa9c9dbf14f44c
  $fToJSONViewName_$ctoJSONList ::
    [View.ViewName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewName
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (View.N:ViewName[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
7e5d36f7e783c2d90ec1543a8051fd13
  $fToJSONViewRow :: Data.Aeson.Types.ToJSON.ToJSON View.ViewRow
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ View.ViewRow
                  ProjectJson.$fToJSONView_$ctoJSON1
                  ProjectJson.$fToJSONViewRow_$ctoEncoding
                  ProjectJson.$fToJSONViewRow_$ctoJSONList
                  ProjectJson.$fToJSONViewRow_$ctoEncodingList -}
b7672cacd244a392f097bee129a98174
  $fToJSONViewRow_$ctoEncoding ::
    View.ViewRow -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <L,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: View.ViewRow) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONView_$ctoJSON1 eta)) -}
a9ced2973b28d0a4ca54d49a38957c6a
  $fToJSONViewRow_$ctoEncodingList ::
    [View.ViewRow] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewRow]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONView_$ctoJSON1 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.ViewRow
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.ViewRow)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONView_$ctoJSON1 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.ViewRow>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
e8b92302d4fe3b4d5ca97e0830fd034b
  $fToJSONViewRow_$ctoJSONList ::
    [View.ViewRow] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.ViewRow]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.ViewRow
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.ViewRow
                                       c
                                       ProjectJson.$fToJSONView_$ctoJSON1)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
ae497a2317d44833efb66e3e562b1bfa
  $fToJSONView_$ctoEncoding ::
    View.View -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: View.View) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONView_$ctoJSON eta)) -}
265594eac8f4ab2b5b0c5f26dd4246a4
  $fToJSONView_$ctoEncodingList ::
    [View.View] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.View]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONView_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ View.View
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: View.View)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONView_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<View.View>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
c33cd2e084e898704416b6c7788c3035
  $fToJSONView_$ctoJSON ::
    View.View -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: View.View) ->
                 case w of ww { View.View ww1 ww2 ->
                 case ProjectJson.$w$ctoJSON9 ww1 ww2 of ww3 { Unit# ww4 ->
                 Data.Aeson.Types.Internal.Object ww4 } }) -}
fb76255c954f22df83a5d9c838ceec24
  $fToJSONView_$ctoJSON1 ::
    View.ViewRow -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <L,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: View.ViewRow) ->
                 case ProjectJson.$w$ctoJSON10 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
703550a3a088bb68da3973cdd71ec994
  $fToJSONView_$ctoJSON2 ::
    View.ViewItem -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: View.ViewItem) ->
                 case ProjectJson.$w$ctoJSON11 w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
0bfcab9655dc2c9757f7d86d4675f7d8
  $fToJSONView_$ctoJSONList ::
    [View.View] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [View.View]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ View.View
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ View.View
                                       c
                                       ProjectJson.$fToJSONView_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
4ae97b6b20a161bc479769ed38f15cc0
  $fToJSONXFormula :: Data.Aeson.Types.ToJSON.ToJSON Formula.XFormula
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Formula.XFormula
                  ProjectJson.$fToJSONCalculation_$ctoJSON2
                  ProjectJson.$fToJSONXFormula_$ctoEncoding
                  ProjectJson.$fToJSONXFormula_$ctoJSONList
                  ProjectJson.$fToJSONXFormula_$ctoEncodingList -}
97e315250951ffc23071835831d84a28
  $fToJSONXFormula_$ctoEncoding ::
    Formula.XFormula -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: Formula.XFormula) ->
                 Data.Aeson.Encoding.Internal.value
                   (ProjectJson.$fToJSONCalculation_$ctoJSON2 eta)) -}
e70fe2e6e6be627d73cd3438f7600193
  $fToJSONXFormula_$ctoEncodingList ::
    [Formula.XFormula] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Formula.XFormula]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (ProjectJson.$fToJSONCalculation_$ctoJSON2 x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ Formula.XFormula
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: Formula.XFormula)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (ProjectJson.$fToJSONCalculation_$ctoJSON2 v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<Formula.XFormula>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
bf232756f936bc3f47bbb8fcf3a13a50
  $fToJSONXFormula_$ctoJSONList ::
    [Formula.XFormula] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [Formula.XFormula]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ Formula.XFormula
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ Formula.XFormula
                                       c
                                       ProjectJson.$fToJSONCalculation_$ctoJSON2)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
123a0049f97eff0899a456bdf3a3ec4b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ProjectJson.$trModule2
                   ProjectJson.$trModule1) -}
9dbc5219cbdb77d6f3e3d64cf0e89a85
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ProjectJson"#) -}
066fff0eb99523f02f77576bb1e968c0
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
ce8751848683596db6eab5e8f8f518b6
  $w$ctoJSON ::
    Calculation.CalculationName
    -> XMapTypes.XMapName
    -> Formula.XFormula
    -> XFunction.OperationMode
    -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Calculation.CalculationName)
                   (ww1 :: XMapTypes.XMapName)
                   (ww2 :: Formula.XFormula)
                   (ww3 :: XFunction.OperationMode) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fToJSONCalculation4,
                            Data.Aeson.Types.Internal.$WString
                              ww `cast` (Calculation.N:CalculationName[0]))
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fToJSONCalculation3,
                               XMapJson.$fToJSONXMapName_$ctoJSON ww1)
                              (GHC.Types.:
                                 @ Data.Aeson.Types.Internal.Pair
                                 (ProjectJson.$fToJSONCalculation2,
                                  ProjectJson.$fToJSONCalculation_$ctoJSON2 ww2)
                                 (GHC.Types.:
                                    @ Data.Aeson.Types.Internal.Pair
                                    (ProjectJson.$fToJSONCalculation1,
                                     ProjectJson.$fToJSONCalculation_$ctoJSON1 ww3)
                                    (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
c51dbcad8d2002b9644cc554ce86a106
  $w$ctoJSON1 ::
    XFunction.OperationMode -> (# Data.Text.Internal.Text #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: XFunction.OperationMode) ->
                 case case w of wild {
                        XFunction.Union -> XFunction.$fReadOperationMode11
                        XFunction.Intersection
                        -> XFunction.$fReadOperationMode8 } of dt { DEFAULT ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ Data.Text.Internal.Text
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         TextEnums.$wouter ipv1 4# dt 0# ipv }) of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of dt1 { Data.Text.Internal.Text ipv2 ipv3 ipv4 ->
                 (# dt1 #) } } }) -}
0a68ac14a3b730673871af7d8d3956f0
  $w$ctoJSON10 ::
    View.ViewRow -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (w :: View.ViewRow) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONViewRow1,
                            case GHC.Magic.runRW#
                                   @ 'GHC.Types.PtrRepLifted
                                   @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                   (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                    case GHC.Prim.newArray#
                                           @ Data.Aeson.Types.Internal.Value
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           0#
                                           (Data.Vector.Mutable.uninitialised
                                              @ Data.Aeson.Types.Internal.Value)
                                           s1
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                    case ProjectJson.$fToJSONView7
                                           GHC.Types.SPEC
                                           ((Data.Vector.Mutable.MVector
                                               @ (Control.Monad.Primitive.PrimState
                                                    (GHC.ST.ST GHC.Prim.RealWorld))
                                               @ Data.Aeson.Types.Internal.Value
                                               0#
                                               0#
                                               ipv1)
                                              `cast`
                                            (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                             (GHC.ST.ST
                                                                                                GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                            ProjectJson.$fToJSONFunctions3)
                                           (GHC.Base.map
                                              @ View.ViewItem
                                              @ Data.Aeson.Types.Internal.Value
                                              ProjectJson.$fToJSONView_$ctoJSON2
                                              w `cast` (View.N:ViewRow[0]))
                                           ipv
                                             `cast`
                                           (GHC.Prim.State#
                                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                   <GHC.Prim.RealWorld>_N))_R of ds2 { (#,#) ipv6 ipv7 ->
                                    case ipv7 of wild5 { (,) v' n ->
                                    case v'
                                           `cast`
                                         (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                    (GHC.ST.ST
                                                                                       GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                    case n of dt5 { GHC.Types.I# dt6 ->
                                    case GHC.Prim.unsafeFreezeArray#
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           @ Data.Aeson.Types.Internal.Value
                                           dt2
                                           ipv6
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                    (# ipv2
                                         `cast`
                                       (GHC.Prim.State#
                                          (Control.Monad.Primitive.D:R:PrimStateST[0]
                                               <GHC.Prim.RealWorld>_N))_R,
                                       Data.Vector.Vector
                                         @ Data.Aeson.Types.Internal.Value
                                         dt
                                         dt6
                                         ipv3 #) } } } } } }) of ds1 { (#,#) ipv1 ipv2 ->
                            case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                            Data.Aeson.Types.Internal.Array dt1 } })
                           (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
9bf95825957c0d1fee45aa7bb3c6ae90
  $w$ctoJSON11 ::
    View.ViewItem -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: View.ViewItem) ->
                 case w of wild {
                   View.MapItem mapName
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONView5
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONView4,
                                    XMapJson.$fToJSONXMapName_$ctoJSON mapName)
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) }
                   View.LabelItem label
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                ProjectJson.$fToJSONView2
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (ProjectJson.$fToJSONView1,
                                    Data.Aeson.Types.Internal.$WString
                                      label `cast` (View.N:ViewLabel[0]))
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) } }) -}
41f5c702e6061dcf6f802e09b4be9f27
  $w$ctoJSON2 ::
    Formula.XFormula -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
e2465f7fd0d120ee4810d00685e606d0
  $w$ctoJSON3 ::
    Calculation.CalculationName
    -> XMapTypes.XMapName
    -> Calculation.CalculationFormulaText
    -> XFunction.OperationMode
    -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Calculation.CalculationName)
                   (ww1 :: XMapTypes.XMapName)
                   (ww2 :: Calculation.CalculationFormulaText)
                   (ww3 :: XFunction.OperationMode) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fToJSONCalculation4,
                            Data.Aeson.Types.Internal.$WString
                              ww `cast` (Calculation.N:CalculationName[0]))
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fToJSONCalculation3,
                               XMapJson.$fToJSONXMapName_$ctoJSON ww1)
                              (GHC.Types.:
                                 @ Data.Aeson.Types.Internal.Pair
                                 (ProjectJson.$fToJSONCalculationSource1,
                                  Data.Aeson.Types.Internal.$WString
                                    ww2 `cast` (Calculation.N:CalculationFormulaText[0]))
                                 (GHC.Types.:
                                    @ Data.Aeson.Types.Internal.Pair
                                    (ProjectJson.$fToJSONCalculation1,
                                     ProjectJson.$fToJSONCalculation_$ctoJSON1 ww3)
                                    (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
91763083f6bba5c2f3ece9e707ca17c5
  $w$ctoJSON4 ::
    [OperationTypes.OperationName]
    -> [ApplicationTypes.ApplicationName]
    -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 2, Strictness: <L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [OperationTypes.OperationName])
                   (ww1 :: [ApplicationTypes.ApplicationName]) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fToJSONFunctions5,
                            case GHC.Magic.runRW#
                                   @ 'GHC.Types.PtrRepLifted
                                   @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                   (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                    case GHC.Prim.newArray#
                                           @ Data.Aeson.Types.Internal.Value
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           0#
                                           (Data.Vector.Mutable.uninitialised
                                              @ Data.Aeson.Types.Internal.Value)
                                           s1
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                    case ProjectJson.$fToJSONFunctions4
                                           GHC.Types.SPEC
                                           ((Data.Vector.Mutable.MVector
                                               @ (Control.Monad.Primitive.PrimState
                                                    (GHC.ST.ST GHC.Prim.RealWorld))
                                               @ Data.Aeson.Types.Internal.Value
                                               0#
                                               0#
                                               ipv1)
                                              `cast`
                                            (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                             (GHC.ST.ST
                                                                                                GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                            ProjectJson.$fToJSONFunctions3)
                                           (GHC.Base.map
                                              @ OperationTypes.OperationName
                                              @ Data.Aeson.Types.Internal.Value
                                              ProjectJson.$fToJSONFunctions_$ctoJSON1
                                              ww)
                                           ipv
                                             `cast`
                                           (GHC.Prim.State#
                                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                   <GHC.Prim.RealWorld>_N))_R of ds2 { (#,#) ipv6 ipv7 ->
                                    case ipv7 of wild5 { (,) v' n ->
                                    case v'
                                           `cast`
                                         (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                    (GHC.ST.ST
                                                                                       GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                    case n of dt5 { GHC.Types.I# dt6 ->
                                    case GHC.Prim.unsafeFreezeArray#
                                           @ (Control.Monad.Primitive.PrimState
                                                (GHC.ST.ST GHC.Prim.RealWorld))
                                           @ Data.Aeson.Types.Internal.Value
                                           dt2
                                           ipv6
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                        <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                    (# ipv2
                                         `cast`
                                       (GHC.Prim.State#
                                          (Control.Monad.Primitive.D:R:PrimStateST[0]
                                               <GHC.Prim.RealWorld>_N))_R,
                                       Data.Vector.Vector
                                         @ Data.Aeson.Types.Internal.Value
                                         dt
                                         dt6
                                         ipv3 #) } } } } } }) of ds1 { (#,#) ipv1 ipv2 ->
                            case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                            Data.Aeson.Types.Internal.Array dt1 } })
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fToJSONFunctions2,
                               case GHC.Magic.runRW#
                                      @ 'GHC.Types.PtrRepLifted
                                      @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                      (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.newArray#
                                              @ Data.Aeson.Types.Internal.Value
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              0#
                                              (Data.Vector.Mutable.uninitialised
                                                 @ Data.Aeson.Types.Internal.Value)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       case ProjectJson.$fToJSONFunctions1
                                              GHC.Types.SPEC
                                              ((Data.Vector.Mutable.MVector
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  @ Data.Aeson.Types.Internal.Value
                                                  0#
                                                  0#
                                                  ipv1)
                                                 `cast`
                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                (GHC.ST.ST
                                                                                                   GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                               ProjectJson.$fToJSONFunctions3)
                                              (GHC.Base.map
                                                 @ ApplicationTypes.ApplicationName
                                                 @ Data.Aeson.Types.Internal.Value
                                                 ProjectJson.$fToJSONApplicationName_$ctoJSON
                                                 ww1)
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of ds2 { (#,#) ipv6 ipv7 ->
                                       case ipv7 of wild5 { (,) v' n ->
                                       case v'
                                              `cast`
                                            (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       (GHC.ST.ST
                                                                                          GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                       case n of dt5 { GHC.Types.I# dt6 ->
                                       case GHC.Prim.unsafeFreezeArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              @ Data.Aeson.Types.Internal.Value
                                              dt2
                                              ipv6
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          Data.Vector.Vector
                                            @ Data.Aeson.Types.Internal.Value
                                            dt
                                            dt6
                                            ipv3 #) } } } } } }) of ds1 { (#,#) ipv1 ipv2 ->
                               case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                               Data.Aeson.Types.Internal.Array dt1 } })
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
115164f96ace27e3937faca2ffb1bbfa
  $w$ctoJSON5 ::
    OperationTypes.OperationName -> (# Data.Text.Internal.Text #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: OperationTypes.OperationName) ->
                 case case w of wild {
                        OperationTypes.Add -> OperationTypes.$fReadOperationName11
                        OperationTypes.Subtract
                        -> OperationTypes.$fReadOperationName8 } of dt { DEFAULT ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ Data.Text.Internal.Text
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ GHC.Prim.RealWorld
                                10#
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         TextEnums.$wouter ipv1 4# dt 0# ipv }) of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of dt1 { Data.Text.Internal.Text ipv2 ipv3 ipv4 ->
                 (# dt1 #) } } }) -}
5f4bd7fe046f17cee651418d704f024d
  $w$ctoJSON6 ::
    Project.ProjectName
    -> [Calculation.CalculationName]
    -> [View.ViewName]
    -> [Project.Source]
    -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,1*U>, Inline: [0] -}
bce1179d197df8ae9b4e17cce09d69b9
  $w$ctoJSON7 ::
    Project.SourceType
    -> [XMapTypes.XMapName] -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 2, Strictness: <L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Project.SourceType)
                   (ww1 :: [XMapTypes.XMapName]) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONSource6,
                            ProjectJson.$fToJSONSource_$ctoJSON1 ww)
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fFromJSONSource2,
                               case GHC.Magic.runRW#
                                      @ 'GHC.Types.PtrRepLifted
                                      @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                      (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.newArray#
                                              @ Data.Aeson.Types.Internal.Value
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              0#
                                              (Data.Vector.Mutable.uninitialised
                                                 @ Data.Aeson.Types.Internal.Value)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       case ProjectJson.$fToJSONSource1
                                              GHC.Types.SPEC
                                              ((Data.Vector.Mutable.MVector
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  @ Data.Aeson.Types.Internal.Value
                                                  0#
                                                  0#
                                                  ipv1)
                                                 `cast`
                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                (GHC.ST.ST
                                                                                                   GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                               ProjectJson.$fToJSONFunctions3)
                                              (GHC.Base.map
                                                 @ XMapTypes.XMapName
                                                 @ Data.Aeson.Types.Internal.Value
                                                 XMapJson.$fToJSONXMapName_$ctoJSON
                                                 ww1)
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of ds2 { (#,#) ipv6 ipv7 ->
                                       case ipv7 of wild5 { (,) v' n ->
                                       case v'
                                              `cast`
                                            (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       (GHC.ST.ST
                                                                                          GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                       case n of dt5 { GHC.Types.I# dt6 ->
                                       case GHC.Prim.unsafeFreezeArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              @ Data.Aeson.Types.Internal.Value
                                              dt2
                                              ipv6
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          Data.Vector.Vector
                                            @ Data.Aeson.Types.Internal.Value
                                            dt
                                            dt6
                                            ipv3 #) } } } } } }) of ds1 { (#,#) ipv1 ipv2 ->
                               case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                               Data.Aeson.Types.Internal.Array dt1 } })
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
382d1e101ee40aec7c1493893231a18b
  $w$ctoJSON8 ::
    Data.Text.Internal.Text
    -> [Project.ProjectName] -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Data.Text.Internal.Text)
                   (ww1 :: [Project.ProjectName]) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONUser5,
                            Data.Aeson.Types.Internal.$WString ww)
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fFromJSONUser2,
                               case GHC.Magic.runRW#
                                      @ 'GHC.Types.PtrRepLifted
                                      @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                      (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.newArray#
                                              @ Data.Aeson.Types.Internal.Value
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              0#
                                              (Data.Vector.Mutable.uninitialised
                                                 @ Data.Aeson.Types.Internal.Value)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       case ProjectJson.$fToJSONUser1
                                              GHC.Types.SPEC
                                              ((Data.Vector.Mutable.MVector
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  @ Data.Aeson.Types.Internal.Value
                                                  0#
                                                  0#
                                                  ipv1)
                                                 `cast`
                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                (GHC.ST.ST
                                                                                                   GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                               ProjectJson.$fToJSONFunctions3)
                                              (GHC.Base.map
                                                 @ Project.ProjectName
                                                 @ Data.Aeson.Types.Internal.Value
                                                 Data.Aeson.Types.Internal.$WString
                                                   `cast`
                                                 (Sym (Project.N:ProjectName[0])
                                                  ->_R <Data.Aeson.Types.Internal.Value>_R)
                                                 ww1)
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of ds2 { (#,#) ipv6 ipv7 ->
                                       case ipv7 of wild5 { (,) v' n ->
                                       case v'
                                              `cast`
                                            (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       (GHC.ST.ST
                                                                                          GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                       case n of dt5 { GHC.Types.I# dt6 ->
                                       case GHC.Prim.unsafeFreezeArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              @ Data.Aeson.Types.Internal.Value
                                              dt2
                                              ipv6
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          Data.Vector.Vector
                                            @ Data.Aeson.Types.Internal.Value
                                            dt
                                            dt6
                                            ipv3 #) } } } } } }) of ds1 { (#,#) ipv1 ipv2 ->
                               case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                               Data.Aeson.Types.Internal.Array dt1 } })
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
cde65437cf0d8237d3936befdbb84a3b
  $w$ctoJSON9 ::
    View.ViewName
    -> [View.ViewRow] -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: View.ViewName) (ww1 :: [View.ViewRow]) ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (ProjectJson.$fFromJSONView6,
                            Data.Aeson.Types.Internal.$WString ww `cast` (View.N:ViewName[0]))
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (ProjectJson.$fFromJSONView2,
                               case GHC.Magic.runRW#
                                      @ 'GHC.Types.PtrRepLifted
                                      @ (Data.Vector.Vector Data.Aeson.Types.Internal.Value)
                                      (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.newArray#
                                              @ Data.Aeson.Types.Internal.Value
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              0#
                                              (Data.Vector.Mutable.uninitialised
                                                 @ Data.Aeson.Types.Internal.Value)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       case ProjectJson.$fToJSONView8
                                              GHC.Types.SPEC
                                              ((Data.Vector.Mutable.MVector
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  @ Data.Aeson.Types.Internal.Value
                                                  0#
                                                  0#
                                                  ipv1)
                                                 `cast`
                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                (GHC.ST.ST
                                                                                                   GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N),
                                               ProjectJson.$fToJSONFunctions3)
                                              (GHC.Base.map
                                                 @ View.ViewRow
                                                 @ Data.Aeson.Types.Internal.Value
                                                 ProjectJson.$fToJSONView_$ctoJSON1
                                                 ww1)
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of ds2 { (#,#) ipv6 ipv7 ->
                                       case ipv7 of wild5 { (,) v' n ->
                                       case v'
                                              `cast`
                                            (Sub (Data.Vector.D:R:MutableVector[0]) <Control.Monad.Primitive.PrimState
                                                                                       (GHC.ST.ST
                                                                                          GHC.Prim.RealWorld)>_N <Data.Aeson.Types.Internal.Value>_N) of wild { Data.Vector.Mutable.MVector dt dt1 dt2 ->
                                       case n of dt5 { GHC.Types.I# dt6 ->
                                       case GHC.Prim.unsafeFreezeArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              @ Data.Aeson.Types.Internal.Value
                                              dt2
                                              ipv6
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          Data.Vector.Vector
                                            @ Data.Aeson.Types.Internal.Value
                                            dt
                                            dt6
                                            ipv3 #) } } } } } }) of ds1 { (#,#) ipv1 ipv2 ->
                               case ipv2 of dt1 { Data.Vector.Vector ipv ipv4 ipv5 ->
                               Data.Aeson.Types.Internal.Array dt1 } })
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 (# dt #) }) -}
f2ca613e2a05dd3b4019a329bb3ba747
  $w$slookup ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap Data.Text.Internal.Text v
    -> GHC.Base.Maybe v
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><S,U><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ v
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (w :: Data.HashMap.Base.HashMap Data.Text.Internal.Text v) ->
                 case {__pkg_ccall hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol hashable_fnv_hash_offset GHC.Prim.ByteArray#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.State#
                                                                                                                          GHC.Prim.RealWorld
                                                                                                                     -> (# GHC.Prim.State#
                                                                                                                             GHC.Prim.RealWorld,
                                                                                                                           GHC.Prim.Int# #)}
                        ww
                        (GHC.Prim.uncheckedIShiftL# ww1 1#)
                        (GHC.Prim.uncheckedIShiftL# ww2 1#)
                        -2578643520546668380#
                        GHC.Prim.realWorld# of wild1 { (#,#) ds1 ds2 ->
                 ProjectJson.$wpoly_go2
                   @ v
                   (GHC.Prim.int2Word# ds2)
                   ww
                   ww1
                   ww2
                   0#
                   w }) -}
4e3685106bc17bd3ec8acd3d84fbc42f
  $wpoly_go1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array#
         (Data.HashMap.Base.Leaf Data.Text.Internal.Text v)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe v
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><S,U><S,U><S,U>, Inline: [0] -}
13bd039bae738a516852d8e7b25ae22f
  $wpoly_go2 ::
    GHC.Prim.Word#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap Data.Text.Internal.Text v
    -> GHC.Base.Maybe v
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><S,1*U>, Inline: [0] -}
instance Data.Aeson.Types.FromJSON.FromJSON [Project.AllProjects]
  = ProjectJson.$fFromJSONAllProjects
instance Data.Aeson.Types.FromJSON.FromJSON [ApplicationTypes.ApplicationName]
  = ProjectJson.$fFromJSONApplicationName
instance Data.Aeson.Types.FromJSON.FromJSON [Calculation.Calculation]
  = ProjectJson.$fFromJSONCalculation
instance Data.Aeson.Types.FromJSON.FromJSON [Calculation.CalculationFormulaText]
  = ProjectJson.$fFromJSONCalculationFormulaText
instance Data.Aeson.Types.FromJSON.FromJSON [Calculation.CalculationName]
  = ProjectJson.$fFromJSONCalculationName
instance Data.Aeson.Types.FromJSON.FromJSON [Calculation.CalculationSource]
  = ProjectJson.$fFromJSONCalculationSource
instance Data.Aeson.Types.FromJSON.FromJSON [XFunction.OperationMode]
  = ProjectJson.$fFromJSONOperationMode
instance Data.Aeson.Types.FromJSON.FromJSON [OperationTypes.OperationName]
  = ProjectJson.$fFromJSONOperationName
instance Data.Aeson.Types.FromJSON.FromJSON [Project.Project]
  = ProjectJson.$fFromJSONProject
instance Data.Aeson.Types.FromJSON.FromJSON [Project.ProjectName]
  = ProjectJson.$fFromJSONProjectName
instance Data.Aeson.Types.FromJSON.FromJSON [Project.Source]
  = ProjectJson.$fFromJSONSource
instance Data.Aeson.Types.FromJSON.FromJSON [Project.SourceType]
  = ProjectJson.$fFromJSONSourceType
instance Data.Aeson.Types.FromJSON.FromJSON [Project.User]
  = ProjectJson.$fFromJSONUser
instance Data.Aeson.Types.FromJSON.FromJSON [View.View]
  = ProjectJson.$fFromJSONView
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewItem]
  = ProjectJson.$fFromJSONViewItem
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewLabel]
  = ProjectJson.$fFromJSONViewLabel
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewName]
  = ProjectJson.$fFromJSONViewName
instance Data.Aeson.Types.FromJSON.FromJSON [View.ViewRow]
  = ProjectJson.$fFromJSONViewRow
instance Data.Aeson.Types.FromJSON.FromJSON [Formula.XFormula]
  = ProjectJson.$fFromJSONXFormula
instance Data.Aeson.Types.ToJSON.ToJSON [Project.AllProjects]
  = ProjectJson.$fToJSONAllProjects
instance Data.Aeson.Types.ToJSON.ToJSON [ApplicationTypes.ApplicationName]
  = ProjectJson.$fToJSONApplicationName
instance Data.Aeson.Types.ToJSON.ToJSON [Calculation.Calculation]
  = ProjectJson.$fToJSONCalculation
instance Data.Aeson.Types.ToJSON.ToJSON [Calculation.CalculationFormulaText]
  = ProjectJson.$fToJSONCalculationFormulaText
instance Data.Aeson.Types.ToJSON.ToJSON [Calculation.CalculationName]
  = ProjectJson.$fToJSONCalculationName
instance Data.Aeson.Types.ToJSON.ToJSON [Calculation.CalculationSource]
  = ProjectJson.$fToJSONCalculationSource
instance Data.Aeson.Types.ToJSON.ToJSON [Calculation.Functions]
  = ProjectJson.$fToJSONFunctions
instance Data.Aeson.Types.ToJSON.ToJSON [XFunction.OperationMode]
  = ProjectJson.$fToJSONOperationMode
instance Data.Aeson.Types.ToJSON.ToJSON [OperationTypes.OperationName]
  = ProjectJson.$fToJSONOperationName
instance Data.Aeson.Types.ToJSON.ToJSON [Project.Project]
  = ProjectJson.$fToJSONProject
instance Data.Aeson.Types.ToJSON.ToJSON [Project.ProjectName]
  = ProjectJson.$fToJSONProjectName
instance Data.Aeson.Types.ToJSON.ToJSON [Project.Source]
  = ProjectJson.$fToJSONSource
instance Data.Aeson.Types.ToJSON.ToJSON [Project.SourceType]
  = ProjectJson.$fToJSONSourceType
instance Data.Aeson.Types.ToJSON.ToJSON [Project.User]
  = ProjectJson.$fToJSONUser
instance Data.Aeson.Types.ToJSON.ToJSON [View.View]
  = ProjectJson.$fToJSONView
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewItem]
  = ProjectJson.$fToJSONViewItem
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewLabel]
  = ProjectJson.$fToJSONViewLabel
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewName]
  = ProjectJson.$fToJSONViewName
instance Data.Aeson.Types.ToJSON.ToJSON [View.ViewRow]
  = ProjectJson.$fToJSONViewRow
instance Data.Aeson.Types.ToJSON.ToJSON [Formula.XFormula]
  = ProjectJson.$fToJSONXFormula
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

