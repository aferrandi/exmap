
==================== FINAL INTERFACE ====================
2018-01-04 07:11:03.492305082 UTC

interface main@main:XMapJson [orphan module] 8002
  interface hash: b272a52a0859a896ae4ee1500824a762
  ABI hash: c20984cd2df0cdd5c0b86c8fb49b2e16
  export-list hash: 4ac2a0aa4bf208de6d454547f1cdad95
  orphan hash: be57f1af09bb9be47777d9e9885e969e
  flag hash: 73a3d7fa5cb5ccfee42bfbaa2a11c30b
  sig of: Nothing
  used TH splices: False
  where
exports:
module dependencies: Errors XMapTypes
package dependencies: aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK
                      array-0.5.1.1@array-0.5.1.1
                      attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna
                      base-4.9.1.0
                      base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0
                      dlist-0.8.0.3@dlist-0.8.0.3-BHFBNaw8k6n9WiaUNzoXpk
                      ghc-boot-th-8.0.2@ghc-boot-th-8.0.2 ghc-prim-0.5.0.0
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      integer-gmp-1.0.0.1
                      integer-logarithms-1.0.2@integer-logarithms-1.0.2-92lMiWV9mmYAwfMEYgfQ0D
                      primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh
                      random-1.1@random-1.1-9tceXaeYIMZ4JrKq20Egog
                      scientific-0.3.5.1@scientific-0.3.5.1-JHsAAp34Yyd8e5v3sK3O5Q
                      tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt
                      template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      time-1.6.0.1@time-1.6.0.1
                      time-locale-compat-0.1.1.3@time-locale-compat-0.1.1.3-KZ1jqNx8uhlHjmuPPj6V1Y
                      transformers-0.5.2.0@transformers-0.5.2.0
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
                      uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ
                      vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ
orphans: attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.ByteString.Char8
         attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.Text.Internal
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Fusion.Bundle
         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
family instance modules: attoparsec-0.13.1.0@attoparsec-0.13.1.0-8bUdsjh6UCE83aHCxOEHna:Data.Attoparsec.Internal.Types
                         base-4.9.1.0:Control.Applicative base-4.9.1.0:Data.Complex
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Compose
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         dlist-0.8.0.3@dlist-0.8.0.3-BHFBNaw8k6n9WiaUNzoXpk:Data.DList
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Control.Monad.Primitive
                         primitive-0.6.2.0@primitive-0.6.2.0-4578caNkWQ54Gt1mxLF2Yh:Data.Primitive.Array
                         tagged-0.8.5@tagged-0.8.5-1mTloBSoUxv8dqUr8XBGBt:Data.Tagged
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
                         uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ:Data.UUID.Types.Internal
                         uuid-types-1.0.3@uuid-types-1.0.3-HQOuja9trySCcuflACyDTJ:Data.UUID.Types.Internal.Builder
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Primitive
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Storable
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed
                         vector-0.12.0.1@vector-0.12.0.1-692PQMDMB6pIQ1uGwefDcQ:Data.Vector.Unboxed.Base
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson 2e25d14a91e9ff13092f56c3ec0cd425
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types 0fcc3cc9c5c9e4ef1dd20d811966500c
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.FromJSON 4689ca8eaf34be826a16963134272afc
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.Internal c533249add6a1886866510b882a9b441
import  -/  aeson-1.1.2.0@aeson-1.1.2.0-H8KqCgI8gcq2RuIUkNEZvK:Data.Aeson.Types.ToJSON 032e11a60f09165b3d041ef0b452cae8
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  XMapTypes 83c3b05a6c33968c2e0bd82cfc322a5e
  exports: 63a1ffc24fb40991afaa24415fd501be
  XMap c2ed918b428722f1755c470b6338cf45
  XMapBool fc0289d5a53ceeb40b9eaf72c324dfad
  XMapDouble 64dca8f535e90282d4c575c17aea9c9a
  XMapInt d7e7675449f1dd11565e3e9279db009c
  XMapKey 9a8f689ba36840dff52b69a07d7eb5cf
  XMapKey 1916c309a17eb87a716b743dbaee092c
  XMapName 0be109e6102724ac02eab934889766c9
  XMapName aed4e1c98ee09424176ec799b4e99672
  XMapString 31f61ddbcce00d56a11eab12eda7e3f5
  XNamedMap 7cf2fcb1a016d4dff7eb6742faa16f39
  XNamedMap eb3d1aa1ee70c44efd717a55a4d51a32
import  -/  text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text 28074c70d3351fb3368d27c0a438ae07
import  -/  unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base 42bdf194c392fb9c910c94a2b5aa1ff1
import  -/  unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Lazy fc12dd068603a4b3dd39186b8a9fe7b5
d9e368832389582e15d7575c9f3a2e8b
  $fFromJSONKeyXMapKey ::
    Data.Aeson.Types.FromJSON.FromJSONKey XMapTypes.XMapKey
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapKey
                  XMapJson.$fFromJSONKeyXMapKey_$cfromJSONKey
                  XMapJson.$fFromJSONKeyXMapKey_$cfromJSONKeyList -}
7b14984c7ba2961c7836912ed33eb093
  $fFromJSONKeyXMapKey1 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XMapKey] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
5224830ab4f4eebadfa6650b47e8a7bf
  $fFromJSONKeyXMapKey2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "[a]"#) -}
7bafe17db6d47a8356b0c24a192babd2
  $fFromJSONKeyXMapKey3 ::
    Data.Text.Internal.Text -> Data.Text.Internal.Text
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ (tpl :: Data.Text.Internal.Text) -> tpl) -}
c884bada10971b750b607133c53f0880
  $fFromJSONKeyXMapKey_$cfromJSONKey ::
    Data.Aeson.Types.FromJSON.FromJSONKeyFunction XMapTypes.XMapKey
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Data.Aeson.Types.FromJSON.FromJSONKeyText
                   @ XMapTypes.XMapKey
                   XMapJson.$fFromJSONKeyXMapKey3
                     `cast`
                   (<Data.Text.Internal.Text>_R ->_R Sym (XMapTypes.N:XMapKey[0]))) -}
e276c27b68eff54ae6aa493c2c3d3933
  $fFromJSONKeyXMapKey_$cfromJSONKeyList ::
    Data.Aeson.Types.FromJSON.FromJSONKeyFunction [XMapTypes.XMapKey]
  {- Strictness: m4,
     Unfolding: (Data.Aeson.Types.FromJSON.FromJSONKeyValue
                   @ [XMapTypes.XMapKey]
                   XMapJson.$fFromJSONKeyXMapKey_$cparseJSONList) -}
6f2d9353ffb34bc82815879d145be6ef
  $fFromJSONKeyXMapKey_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XMapKey]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XMapKey]
                        XMapJson.$fFromJSONKeyXMapKey2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (XMapJson.$fFromJSONKeyXMapKey1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          XMapJson.$fFromJSONKeyXMapKey_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XMapKey]>_R)) } }) -}
8a2e8020360041cea3d0cf31a0d49e14
  $fFromJSONKeyXMapKey_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
c053e3d8647c34e46f032082864ff379
  $fFromJSONXMap :: Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMap
                  XMapJson.$fFromJSONXMap_$cparseJSON
                  XMapJson.$fFromJSONXMap_$cparseJSONList -}
0beeeaea24d86714d596d044ab0432ff
  $fFromJSONXMap1 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XMap]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XMap] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
e970963f062b2f1926c080633db29661
  $fFromJSONXMapKey ::
    Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XMapKey
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapKey
                  XMapJson.$fFromJSONXMapKey_$cparseJSON
                  XMapJson.$fFromJSONKeyXMapKey_$cparseJSONList -}
af63480954a172c70b53285deaffa1dd
  $fFromJSONXMapKey1 ::
    Data.Aeson.Types.Internal.Value
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success XMapTypes.XMapKey f r
       -> f r
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (ds :: Data.Aeson.Types.Internal.Value)
                   @ (f :: * -> *)
                   @ r
                   (eta :: Data.Aeson.Types.Internal.JSONPath)
                   (eta1 :: Data.Aeson.Types.Internal.Failure f r)
                   (eta2 :: Data.Aeson.Types.Internal.Success
                              XMapTypes.XMapKey f r) ->
                 case ds of wild {
                   DEFAULT -> case XMapJson.$fFromJSONXMapKey2 ret_ty (f r) of {}
                   Data.Aeson.Types.Internal.String v
                   -> eta2 v `cast` (Sym (XMapTypes.N:XMapKey[0])) }) -}
c96f62d21641dc85ba876c0281d5aa4f
  $fFromJSONXMapKey2 ::
    Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey
  {- Strictness: x -}
0aa862e28d983710d8a3ef6d33f99eee
  $fFromJSONXMapKey_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XMapKey
  {- Arity: 4, Strictness: <S,1*U><L,A><L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (0, True, True)
                XMapJson.$fFromJSONXMapKey1
                  `cast`
                (<Data.Aeson.Types.Internal.Value>_R
                 ->_R Sym (Data.Aeson.Types.Internal.N:Parser[0]
                               <XMapTypes.XMapKey>_R)) -}
6b0dfdd3f3bb7a752feaae2f249b9c16
  $fFromJSONXMapName ::
    Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XMapName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapName
                  XMapJson.$fFromJSONXMapName_$cparseJSON
                  XMapJson.$fFromJSONXMapName_$cparseJSONList -}
3f52fc453086a98a1667a8ad147b2fb5
  $fFromJSONXMapName1 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XMapName]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XMapName] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
3526578600e353018c6099624948f1dc
  $fFromJSONXMapName_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XMapName
  {- Arity: 1, Strictness: <S,1*U> -}
394f8767274c8c54c17fe56d8662a02e
  $fFromJSONXMapName_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XMapName]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XMapName]
                        XMapJson.$fFromJSONKeyXMapKey2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (XMapJson.$fFromJSONXMapName1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          XMapJson.$fFromJSONXMapName_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XMapName]>_R)) } }) -}
b73a43b26543ea4ede55e7d6de1602b5
  $fFromJSONXMapName_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XMapName]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
68fee80d51457fe419b26baeba72270c
  $fFromJSONXMap_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XMap
  {- Arity: 1, Strictness: <S,1*U> -}
e067c36346c8229c747864201b95e4c2
  $fFromJSONXMap_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XMap]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XMap]
                        XMapJson.$fFromJSONKeyXMapKey2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (XMapJson.$fFromJSONXMap1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          XMapJson.$fFromJSONXMap_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XMap]>_R)) } }) -}
2ee9e6b27cecf820ab4bd5d716179608
  $fFromJSONXMap_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XMap]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
2f2cd3b42a13edbe0ab6e7328ae0da6a
  $fFromJSONXNamedMap ::
    Data.Aeson.Types.FromJSON.FromJSON XMapTypes.XNamedMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XNamedMap
                  XMapJson.$fFromJSONXNamedMap_$cparseJSON
                  XMapJson.$fFromJSONXNamedMap_$cparseJSONList -}
7a711757dd843bfcfd5869f537d7df07
  $fFromJSONXNamedMap1 ::
    [Data.Aeson.Types.Internal.Parser XMapTypes.XNamedMap]
    -> forall (f :: * -> *) r.
       Data.Aeson.Types.Internal.JSONPath
       -> Data.Aeson.Types.Internal.Failure f r
       -> Data.Aeson.Types.Internal.Success [XMapTypes.XNamedMap] f r
       -> f r
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U><L,C(U)> -}
b7dcd926588783035cf21356225af65a
  $fFromJSONXNamedMap_$cparseJSON ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser XMapTypes.XNamedMap
  {- Arity: 1, Strictness: <S,1*U> -}
7d605fddbb6c88cbd8402f4f318a7985
  $fFromJSONXNamedMap_$cparseJSONList ::
    Data.Aeson.Types.Internal.Value
    -> Data.Aeson.Types.Internal.Parser [XMapTypes.XNamedMap]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Data.Aeson.Types.Internal.Value) ->
                 case ds of wild {
                   DEFAULT
                   -> Data.Aeson.Types.FromJSON.typeMismatch
                        @ [XMapTypes.XNamedMap]
                        XMapJson.$fFromJSONKeyXMapKey2
                        wild
                   Data.Aeson.Types.Internal.Array a2
                   -> case a2 of wild1 { Data.Vector.Vector dt dt1 dt2 ->
                      (XMapJson.$fFromJSONXNamedMap1
                         (letrec {
                            $wgo :: GHC.Prim.Int# -> [Data.Aeson.Types.Internal.Value]
                              {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# ww dt1) of wild2 {
                                GHC.Types.False
                                -> case GHC.Prim.indexArray#
                                          @ Data.Aeson.Types.Internal.Value
                                          dt2
                                          (GHC.Prim.+# dt ww) of ds9 { Unit# ipv ->
                                   GHC.Types.:
                                     @ Data.Aeson.Types.Internal.Value
                                     ipv
                                     ($wgo (GHC.Prim.+# ww 1#)) }
                                GHC.Types.True -> GHC.Types.[] @ Data.Aeson.Types.Internal.Value }
                          } in
                          XMapJson.$fFromJSONXNamedMap_go 0# ($wgo 0#)))
                        `cast`
                      (Sym (Data.Aeson.Types.Internal.N:Parser[0]
                                <[XMapTypes.XNamedMap]>_R)) } }) -}
8baa9365c98cb15c689042a41242b7b3
  $fFromJSONXNamedMap_go ::
    GHC.Prim.Int#
    -> [Data.Aeson.Types.Internal.Value]
    -> [Data.Aeson.Types.Internal.Parser XMapTypes.XNamedMap]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
2ae069c75e3a8c24f830e3d828749290
  $fToJSONKeyXMapKey ::
    Data.Aeson.Types.ToJSON.ToJSONKey XMapTypes.XMapKey
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapKey
                  XMapJson.$fToJSONKeyXMapKey_$ctoJSONKey
                  XMapJson.$fToJSONKeyXMapKey_$s$dmtoJSONKeyList -}
43ce6be9838c5801d3cbdfb5278d3a4f
  $fToJSONKeyXMapKey1 ::
    XMapTypes.XMapKey
    -> forall r.
       Data.ByteString.Builder.Internal.BuildStep r
       -> Data.ByteString.Builder.Internal.BufferRange
       -> GHC.Prim.State# GHC.Prim.RealWorld
       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
             Data.ByteString.Builder.Internal.BuildSignal r #)
  {- Arity: 4,
     Strictness: <L,U(U,U,U)><L,C(C1(U(U,U)))><S(SS),1*U(U,U)><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (x :: XMapTypes.XMapKey)
                   @ r
                   (w2 :: Data.ByteString.Builder.Internal.BuildStep r)
                   (w3 :: Data.ByteString.Builder.Internal.BufferRange)
                   (w4 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w3 of ww { Data.ByteString.Builder.Internal.BufferRange ww1 ww2 ->
                 Data.Aeson.Encoding.Builder.$wtext
                   x `cast` (XMapTypes.N:XMapKey[0])
                   @ r
                   w2
                   ww1
                   ww2
                   w4 }) -}
8a433b320e5ab27ae2e2ee485c2b37be
  $fToJSONKeyXMapKey2 :: XMapTypes.XMapKey -> XMapTypes.XMapKey
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: XMapTypes.XMapKey) -> ds) -}
093e9b5115fba6b8df9408e194dc8cb8
  $fToJSONKeyXMapKey_$ctoEncodingList ::
    [XMapTypes.XMapKey] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapKey]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (Data.Aeson.Types.Internal.$WString
                                  x `cast` (XMapTypes.N:XMapKey[0])))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XMapKey
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XMapKey)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (Data.Aeson.Types.Internal.$WString
                                              v `cast` (XMapTypes.N:XMapKey[0])))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XMapKey>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
981fd41f57446237f8cc51acc5221df3
  $fToJSONKeyXMapKey_$ctoJSONKey ::
    Data.Aeson.Types.ToJSON.ToJSONKeyFunction XMapTypes.XMapKey
  {- Strictness: m1,
     Unfolding: (Data.Aeson.Types.ToJSON.ToJSONKeyText
                   @ XMapTypes.XMapKey
                   XMapJson.$fToJSONKeyXMapKey2
                     `cast`
                   (<XMapTypes.XMapKey>_R ->_R XMapTypes.N:XMapKey[0])
                   XMapJson.$fToJSONKeyXMapKey1
                     `cast`
                   (<XMapTypes.XMapKey>_R
                    ->_R Trans
                             (forall (r :: <*>_N).
                              <Data.ByteString.Builder.Internal.BuildStep r>_R
                              ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                              ->_R Sym (GHC.Types.N:IO[0]
                                            <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                             (Trans
                                  (Sym (Data.ByteString.Builder.Internal.N:Builder[0]))
                                  (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                            <Data.Text.Internal.Text>_P))))) -}
2d45e4431aec07c10d663100b5d63c71
  $fToJSONKeyXMapKey_$ctoJSONList ::
    [XMapTypes.XMapKey] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapKey]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XMapKey
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XMapKey
                                       c
                                       Data.Aeson.Types.Internal.$WString
                                         `cast`
                                       (Sym (XMapTypes.N:XMapKey[0])
                                        ->_R <Data.Aeson.Types.Internal.Value>_R))
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
bc980cd5372c2e1398e2870a6b134df7
  $fToJSONKeyXMapKey_$s$dmtoJSONKeyList ::
    Data.Aeson.Types.ToJSON.ToJSONKeyFunction [XMapTypes.XMapKey]
  {- Strictness: m2,
     Unfolding: InlineRule (-2, True, False)
                (Data.Aeson.Types.ToJSON.ToJSONKeyValue
                   @ [XMapTypes.XMapKey]
                   XMapJson.$fToJSONKeyXMapKey_$ctoJSONList
                   XMapJson.$fToJSONKeyXMapKey_$ctoEncodingList) -}
a8331785b2e8b3e68c7d39459aad08f0
  $fToJSONXMap :: Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMap
                  XMapJson.$fToJSONXMap_$ctoJSON
                  XMapJson.$fToJSONXMap_$ctoEncoding
                  XMapJson.$fToJSONXMap_$ctoJSONList
                  XMapJson.$fToJSONXMap_$ctoEncodingList -}
5c06d41f0218d0c0d8f2e6d028dbc139
  $fToJSONXMap1 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((XMapJson.$fToJSONXMap3, XMapJson.$fToJSONXMap2)) -}
266f7e00d9e6e1ee5eb88457f71172c1
  $fToJSONXMap10 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "double"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
71bb6c603b3c217ad55101eab898be50
  $fToJSONXMap2 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "bool"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
3fec35a5bdbaca219ab1981cf71639fb
  $fToJSONXMap3 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "type"#) -}
88d49039005978508ff52af5a6e20cc4
  $fToJSONXMap4 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((XMapJson.$fToJSONXMap3, XMapJson.$fToJSONXMap5)) -}
de1561f402cfb984deb7d00fa51c6ab3
  $fToJSONXMap5 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "string"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
f20ded396ee2e88382debf9f94757112
  $fToJSONXMap6 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((XMapJson.$fToJSONXMap3, XMapJson.$fToJSONXMap7)) -}
e53b06b9efc2d9d053dc0ac64c332081
  $fToJSONXMap7 :: Data.Aeson.Types.Internal.Value
  {- Unfolding: (case Data.Text.Show.unpackCString#
                        "int"# of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
a226cb149d5ba47a529e7957432ea581
  $fToJSONXMap8 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "values"#) -}
04ed0f45d5e0b338ad10820818545927
  $fToJSONXMap9 :: Data.Aeson.Types.Internal.Pair
  {- Strictness: m,
     Unfolding: ((XMapJson.$fToJSONXMap3, XMapJson.$fToJSONXMap10)) -}
00a82b39e8638e5a7d901d189ab5a168
  $fToJSONXMapKey :: Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XMapKey
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapKey
                  Data.Aeson.Types.Internal.$WString
                    `cast`
                  (Sym (XMapTypes.N:XMapKey[0])
                   ->_R <Data.Aeson.Types.Internal.Value>_R)
                  (\ (eta :: XMapTypes.XMapKey) ->
                   Data.Aeson.Encoding.Internal.value
                     (Data.Aeson.Types.Internal.$WString
                        eta `cast` (XMapTypes.N:XMapKey[0])))
                  XMapJson.$fToJSONKeyXMapKey_$ctoJSONList
                  XMapJson.$fToJSONKeyXMapKey_$ctoEncodingList -}
ca40864631be6aca24b3f00f74908b14
  $fToJSONXMapName ::
    Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XMapName
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XMapName
                  XMapJson.$fToJSONXMapName_$ctoJSON
                  XMapJson.$fToJSONXMapName_$ctoEncoding
                  XMapJson.$fToJSONXMapName_$ctoJSONList
                  XMapJson.$fToJSONXMapName_$ctoEncodingList -}
28d12997fa5c7073d2be518d8cbd62c5
  $fToJSONXMapName1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "/"#) -}
d14d02ec7d1cdcdeaf372134c87ef6ad
  $fToJSONXMapName_$ctoEncoding ::
    XMapTypes.XMapName -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XMapTypes.XMapName) ->
                 Data.Aeson.Encoding.Internal.value
                   (XMapJson.$fToJSONXMapName_$ctoJSON eta)) -}
90aec3517b9044bdab00e2b1e0776118
  $fToJSONXMapName_$ctoEncodingList ::
    [XMapTypes.XMapName] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapName]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (XMapJson.$fToJSONXMapName_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XMapName
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XMapName)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (XMapJson.$fToJSONXMapName_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XMapName>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
b2e9527d209ebc86594c4d83ba4bf2c1
  $fToJSONXMapName_$ctoJSON ::
    XMapTypes.XMapName -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m3,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: XMapTypes.XMapName) ->
                 case Data.Text.concat
                        (Data.Text.Internal.Functions.intersperse
                           @ Data.Text.Internal.Text
                           XMapJson.$fToJSONXMapName1
                           ds
                             `cast`
                           (XMapTypes.N:XMapName[0])) of dt { Data.Text.Internal.Text ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.String dt }) -}
f9dda763cfc64f31992800cc27b6e125
  $fToJSONXMapName_$ctoJSONList ::
    [XMapTypes.XMapName] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMapName]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XMapName
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XMapName
                                       c
                                       XMapJson.$fToJSONXMapName_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
9b8bd13c7cab7043b131d0a6bb69bf32
  $fToJSONXMap_$ctoEncoding ::
    XMapTypes.XMap -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XMapTypes.XMap) ->
                 Data.Aeson.Encoding.Internal.value
                   (XMapJson.$fToJSONXMap_$ctoJSON eta)) -}
ce3fe6238d3b180e566c5262557caef6
  $fToJSONXMap_$ctoEncodingList ::
    [XMapTypes.XMap] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMap]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (XMapJson.$fToJSONXMap_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XMap
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XMap)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (XMapJson.$fToJSONXMap_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XMap>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
1acd4a86655935cfb4ad1cc16e5af545
  $fToJSONXMap_$ctoJSON ::
    XMapTypes.XMap -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: XMapTypes.XMap) ->
                 case XMapJson.$w$ctoJSON w of ww { Unit# ww1 ->
                 Data.Aeson.Types.Internal.Object ww1 }) -}
20b0c1b5cbe6370cca98984673532dcf
  $fToJSONXMap_$ctoJSONList ::
    [XMapTypes.XMap] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XMap]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XMap
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XMap
                                       c
                                       XMapJson.$fToJSONXMap_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
fee30544f72e9b86267682e3e3107bbe
  $fToJSONXMap_go1 ::
    Data.HashMap.Base.HashMap
      Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
    -> Data.Map.Base.Map XMapTypes.XMapKey Data.Text.Internal.Text
    -> Data.HashMap.Base.HashMap
         Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
0d609fc1be654e8de3fb6d208289b95d
  $fToJSONXMap_go160 ::
    Data.HashMap.Base.HashMap
      Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
    -> Data.Map.Base.Map XMapTypes.XMapKey GHC.Types.Bool
    -> Data.HashMap.Base.HashMap
         Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
30680345689791a8d36f2190eb3a4eb6
  $fToJSONXMap_go2 ::
    Data.HashMap.Base.HashMap
      Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
    -> Data.Map.Base.Map XMapTypes.XMapKey GHC.Types.Int
    -> Data.HashMap.Base.HashMap
         Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
11c1057eec7cdda19be3c08799149457
  $fToJSONXMap_go3 ::
    Data.HashMap.Base.HashMap
      Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
    -> Data.Map.Base.Map XMapTypes.XMapKey GHC.Types.Double
    -> Data.HashMap.Base.HashMap
         Data.Text.Internal.Text Data.Aeson.Types.Internal.Value
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
9e31693596161ede640f69b7a0dc9598
  $fToJSONXNamedMap ::
    Data.Aeson.Types.ToJSON.ToJSON XMapTypes.XNamedMap
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ XMapTypes.XNamedMap
                  XMapJson.$fToJSONXNamedMap_$ctoJSON
                  XMapJson.$fToJSONXNamedMap_$ctoEncoding
                  XMapJson.$fToJSONXNamedMap_$ctoJSONList
                  XMapJson.$fToJSONXNamedMap_$ctoEncodingList -}
c13f7d21b2f4a678e77757cafbf7bcb9
  $fToJSONXNamedMap1 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "xmap"#) -}
6b220d2be6c4a35b5bef75a573efac87
  $fToJSONXNamedMap2 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString# "mapName"#) -}
518e82ae47707c3cc3a023b4ca596ceb
  $fToJSONXNamedMap_$ctoEncoding ::
    XMapTypes.XNamedMap -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: XMapTypes.XNamedMap) ->
                 Data.Aeson.Encoding.Internal.value
                   (XMapJson.$fToJSONXNamedMap_$ctoJSON eta)) -}
d45579a4af5d2d56631d811d17440b0c
  $fToJSONXNamedMap_$ctoEncodingList ::
    [XMapTypes.XNamedMap] -> Data.Aeson.Encoding.Internal.Encoding
  {- Arity: 1, Strictness: <S,1*U>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XNamedMap]) ->
                 case eta of wild {
                   [] -> Data.Aeson.Encoding.Internal.emptyArray_
                   : x xs
                   -> (Data.ByteString.Builder.Internal.append
                         (Data.Aeson.Encoding.Internal.openBracket
                            @ Data.Aeson.Types.Internal.Value)
                           `cast`
                         (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                              <Data.Aeson.Types.Internal.Value>_P)
                         (Data.ByteString.Builder.Internal.append
                            (Data.Aeson.Encoding.Internal.value
                               (XMapJson.$fToJSONXNamedMap_$ctoJSON x))
                              `cast`
                            (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                 <Data.Aeson.Types.Internal.Value>_P)
                            (Data.ByteString.Builder.Internal.append
                               (GHC.Base.foldr
                                  @ XMapTypes.XNamedMap
                                  @ (Data.Aeson.Encoding.Internal.Encoding'
                                       Data.Aeson.Types.Internal.Value)
                                  (\ (v :: XMapTypes.XNamedMap)
                                     (vs :: Data.Aeson.Encoding.Internal.Encoding'
                                              Data.Aeson.Types.Internal.Value)[OneShot] ->
                                   Data.ByteString.Builder.Internal.append
                                     (Data.Aeson.Encoding.Internal.comma
                                        @ Data.Aeson.Types.Internal.Value)
                                       `cast`
                                     (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                          <Data.Aeson.Types.Internal.Value>_P)
                                     (Data.ByteString.Builder.Internal.append
                                        (Data.Aeson.Encoding.Internal.value
                                           (XMapJson.$fToJSONXNamedMap_$ctoJSON v))
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)
                                        vs
                                          `cast`
                                        (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                             <Data.Aeson.Types.Internal.Value>_P)))
                                    `cast`
                                  (<XMapTypes.XNamedMap>_R
                                   ->_R <Data.Aeson.Encoding.Internal.Encoding'
                                           Data.Aeson.Types.Internal.Value>_R
                                   ->_R Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                                 <Data.Aeson.Types.Internal.Value>_P))
                                  (Data.Aeson.Encoding.Internal.empty
                                     @ Data.Aeson.Types.Internal.Value)
                                  xs)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P)
                               (Data.Aeson.Encoding.Internal.closeBracket
                                  @ Data.Aeson.Types.Internal.Value)
                                 `cast`
                               (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                    <Data.Aeson.Types.Internal.Value>_P))))
                        `cast`
                      (Sym (Data.Aeson.Encoding.Internal.N:Encoding'[0]
                                <Data.Aeson.Types.Internal.Value>_P)) }) -}
8b003e3dc1371f2a6dd078b946e30de4
  $fToJSONXNamedMap_$ctoJSON ::
    XMapTypes.XNamedMap -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>m1, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: XMapTypes.XNamedMap) ->
                 case w of ww { XMapTypes.XNamedMap ww1 ww2 ->
                 case Data.Aeson.Types.Internal.$sfromList1
                        @ Data.Aeson.Types.Internal.Value
                        (GHC.Types.:
                           @ Data.Aeson.Types.Internal.Pair
                           (XMapJson.$fToJSONXNamedMap2,
                            XMapJson.$fToJSONXMapName_$ctoJSON ww1)
                           (GHC.Types.:
                              @ Data.Aeson.Types.Internal.Pair
                              (XMapJson.$fToJSONXNamedMap1, XMapJson.$fToJSONXMap_$ctoJSON ww2)
                              (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                        (Data.HashMap.Base.Empty
                           @ Data.Text.Internal.Text
                           @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                 Data.Aeson.Types.Internal.Object dt } }) -}
5da415314640d08e3fc685695df8b71d
  $fToJSONXNamedMap_$ctoJSONList ::
    [XMapTypes.XNamedMap] -> Data.Aeson.Types.Internal.Value
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ (eta :: [XMapTypes.XNamedMap]) ->
                 case Data.Vector.Generic.new
                        @ Data.Vector.Vector
                        @ Data.Aeson.Types.Internal.Value
                        (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                        (Data.Vector.Generic.New.unstream
                           @ Data.Vector.Vector
                           @ Data.Aeson.Types.Internal.Value
                           (Data.Vector.$fVectorVectora @ Data.Aeson.Types.Internal.Value)
                           (Data.Vector.Fusion.Bundle.Monadic.unsafeFromList
                              @ Data.Vector.Fusion.Util.Id
                              @ Data.Aeson.Types.Internal.Value
                              @ Data.Vector.Vector
                              Data.Vector.Fusion.Util.$fMonadId
                              Data.Vector.Fusion.Bundle.Size.Unknown
                              (GHC.Base.build
                                 @ Data.Aeson.Types.Internal.Value
                                 (\ @ b1
                                    (c :: Data.Aeson.Types.Internal.Value -> b1 -> b1)[OneShot]
                                    (n :: b1)[OneShot] ->
                                  GHC.Base.foldr
                                    @ XMapTypes.XNamedMap
                                    @ b1
                                    (GHC.Base.mapFB
                                       @ Data.Aeson.Types.Internal.Value
                                       @ b1
                                       @ XMapTypes.XNamedMap
                                       c
                                       XMapJson.$fToJSONXNamedMap_$ctoJSON)
                                    n
                                    eta)))) of dt1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                 Data.Aeson.Types.Internal.Array dt1 }) -}
954ee61bc4e9e6c3e64c3c05936e8c3b
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   XMapJson.$trModule2
                   XMapJson.$trModule1) -}
4cf5975de359e4053a08ca0d0a20ea7c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "XMapJson"#) -}
cec16a4ac19e2f97fd236593c589a85c
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
8ce72c88e69af3463e13622df53e640a
  $w$ctoJSON ::
    XMapTypes.XMap -> (# Data.Aeson.Types.Internal.Object #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: XMapTypes.XMap) ->
                 case w of wild {
                   XMapTypes.XMapDouble values
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                XMapJson.$fToJSONXMap9
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (XMapJson.$fToJSONXMap8,
                                    case XMapJson.$fToJSONXMap_go3
                                           (Data.HashMap.Base.Empty
                                              @ Data.Text.Internal.Text
                                              @ Data.Aeson.Types.Internal.Value)
                                           values of dt1 { DEFAULT ->
                                    Data.Aeson.Types.Internal.Object dt1 })
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) }
                   XMapTypes.XMapInt values
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                XMapJson.$fToJSONXMap6
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (XMapJson.$fToJSONXMap8,
                                    case XMapJson.$fToJSONXMap_go2
                                           (Data.HashMap.Base.Empty
                                              @ Data.Text.Internal.Text
                                              @ Data.Aeson.Types.Internal.Value)
                                           values of dt1 { DEFAULT ->
                                    Data.Aeson.Types.Internal.Object dt1 })
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) }
                   XMapTypes.XMapString values
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                XMapJson.$fToJSONXMap4
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (XMapJson.$fToJSONXMap8,
                                    case XMapJson.$fToJSONXMap_go1
                                           (Data.HashMap.Base.Empty
                                              @ Data.Text.Internal.Text
                                              @ Data.Aeson.Types.Internal.Value)
                                           values of dt1 { DEFAULT ->
                                    Data.Aeson.Types.Internal.Object dt1 })
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) }
                   XMapTypes.XMapBool values
                   -> case Data.Aeson.Types.Internal.$sfromList1
                             @ Data.Aeson.Types.Internal.Value
                             (GHC.Types.:
                                @ Data.Aeson.Types.Internal.Pair
                                XMapJson.$fToJSONXMap1
                                (GHC.Types.:
                                   @ Data.Aeson.Types.Internal.Pair
                                   (XMapJson.$fToJSONXMap8,
                                    case XMapJson.$fToJSONXMap_go160
                                           (Data.HashMap.Base.Empty
                                              @ Data.Text.Internal.Text
                                              @ Data.Aeson.Types.Internal.Value)
                                           values of dt1 { DEFAULT ->
                                    Data.Aeson.Types.Internal.Object dt1 })
                                   (GHC.Types.[] @ Data.Aeson.Types.Internal.Pair)))
                             (Data.HashMap.Base.Empty
                                @ Data.Text.Internal.Text
                                @ Data.Aeson.Types.Internal.Value) of dt { DEFAULT ->
                      (# dt #) } }) -}
e73ee7a53f1441c449e8885a8d6ff96e
  $w$sgo10 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> a1
    -> Data.Map.Base.Map XMapTypes.XMapKey a1
    -> Data.Map.Base.Map XMapTypes.XMapKey a1
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
b83239bcf537f0eaab74c025766759ab
  $w$slookup ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap Data.Text.Internal.Text v
    -> GHC.Base.Maybe v
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><S,U><S,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ v
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (w :: Data.HashMap.Base.HashMap Data.Text.Internal.Text v) ->
                 case {__pkg_ccall hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol hashable_fnv_hash_offset GHC.Prim.ByteArray#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.Int#
                                                                                                                     -> GHC.Prim.State#
                                                                                                                          GHC.Prim.RealWorld
                                                                                                                     -> (# GHC.Prim.State#
                                                                                                                             GHC.Prim.RealWorld,
                                                                                                                           GHC.Prim.Int# #)}
                        ww
                        (GHC.Prim.uncheckedIShiftL# ww1 1#)
                        (GHC.Prim.uncheckedIShiftL# ww2 1#)
                        -2578643520546668380#
                        GHC.Prim.realWorld# of wild1 { (#,#) ds9 ds10 ->
                 XMapJson.$wpoly_go2
                   @ v
                   (GHC.Prim.int2Word# ds10)
                   ww
                   ww1
                   ww2
                   0#
                   w }) -}
553a0e834ef4fcd7b10a27126bae5a93
  $wpoly_go1 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array#
         (Data.HashMap.Base.Leaf Data.Text.Internal.Text v)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe v
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><S,U><S,U><S,U>, Inline: [0] -}
881f33dcb7c659edb67a3edd81ab1eb8
  $wpoly_go2 ::
    GHC.Prim.Word#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap Data.Text.Internal.Text v
    -> GHC.Base.Maybe v
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><S,1*U>, Inline: [0] -}
instance Data.Aeson.Types.FromJSON.FromJSONKey [XMapTypes.XMapKey]
  = XMapJson.$fFromJSONKeyXMapKey
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XMap]
  = XMapJson.$fFromJSONXMap
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XMapKey]
  = XMapJson.$fFromJSONXMapKey
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XMapName]
  = XMapJson.$fFromJSONXMapName
instance Data.Aeson.Types.FromJSON.FromJSON [XMapTypes.XNamedMap]
  = XMapJson.$fFromJSONXNamedMap
instance Data.Aeson.Types.ToJSON.ToJSONKey [XMapTypes.XMapKey]
  = XMapJson.$fToJSONKeyXMapKey
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XMap]
  = XMapJson.$fToJSONXMap
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XMapKey]
  = XMapJson.$fToJSONXMapKey
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XMapName]
  = XMapJson.$fToJSONXMapName
instance Data.Aeson.Types.ToJSON.ToJSON [XMapTypes.XNamedMap]
  = XMapJson.$fToJSONXNamedMap
"SPEC/XMapJson $dmtoJSONKeyList @ XMapKey" [ALWAYS] forall ($dToJSON :: Data.Aeson.Types.ToJSON.ToJSON
                                                                          XMapTypes.XMapKey)
                                                           ($dToJSONKey :: Data.Aeson.Types.ToJSON.ToJSONKey
                                                                             XMapTypes.XMapKey)
  Data.Aeson.Types.ToJSON.$dmtoJSONKeyList @ XMapTypes.XMapKey
                                           $dToJSONKey
                                           $dToJSON
  = XMapJson.$fToJSONKeyXMapKey_$s$dmtoJSONKeyList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

